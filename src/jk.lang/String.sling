
/*
 * This file is part of Eqela Jkop
 * Copyright (c) 2016-2024 J42 Pte Ltd
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

class:

description [[
	The String class provides all the common string manipulation functions,
	including comparisons, concatenation, transformations to upper and lowercase,
	getting substrings, finding characters or substrings, splitting the strings,
	converting to byte buffers, etc.
]]

class MyStringObject is StringObject private
{
	prop value as string

	func toString implement as string:
		return value
}

func wrapValue(value as string) static as StringObject:
	return new MyStringObject() {
		value value
	}

func asValueOrNull(obj as dynamic?) static as string?
{
	description [[
		Converts an arbitrary object to a string, if possible. Returns null if not
		possible.
	]]
	if not obj:
		return null
	if obj is string:
		return obj as! string
	if obj is StringObject {
		var os = obj as! StringObject
		return os.toString()
	}
	if obj is int:
		return forInteger(obj as! int)
	if obj is IntegerObject:
		return forInteger((obj as! IntegerObject).toInteger())
	if obj is long:
		return forLongInteger(obj as! long)
	if obj is LongIntegerObject:
		return forLongInteger((obj as! LongIntegerObject).toLongInteger())
	if obj is double:
		return forDouble(obj as! double)
	if obj is DoubleObject:
		return forDouble((obj as! DoubleObject).toDouble())
	if obj is bool:
		return forBoolean(obj as! bool)
	if obj is BooleanObject:
		return forBoolean((obj as! BooleanObject).toBoolean())
	if obj is char:
		return forCharacter(obj as! char)
	if obj is CharacterObject:
		return forCharacter((obj as! CharacterObject).toCharacter())
	if obj is buffer:
		return forBufferHex(obj as! buffer)
	if obj is BufferObject {
		var v = (obj as! BufferObject).toBuffer()
		return forBufferHex(v)
	}
	// FIXME: if obj is DynamicMap
	// FIXME: if obj is KeyValueList
	// FIXME: if obj is DynamicVector
	IFDEF "target_java" {
		return lang "java" as string {{{ obj.toString() }}}
	}
	ELSE IFDEF "target_dotnet_cs" {
		return lang "cs" as string {{{ obj.ToString() }}}
	}
	ELSE IFDEF "target_js" {
		lang "js" {{{
			if(obj instanceof Error) {
				return obj.stack;
			}
		}}}
		var vjs = lang "js" as dynamic {{{ obj.toString() }}}
		lang "js" (vjs) {{{
			if(vjs && vjs != "[object Object]") {
				return vjs;
			}
		}}}
		return null
	}
	ELSE {
		return null
	}
}

func asValueOrThrowError(obj as dynamic?) static throws Exception as string
{
	description [[
		Converts an arbitrary object to a string, if possible. Throws an error if not
		possible.
	]]
	var v = asValueOrNull(obj)
	if not v:
		Error.throw("valueCannotBeConvertedToString", obj)
	return v
}

func asValueOrEmptyString(obj as dynamic?) static as string
{
	description [[
		Converts an arbitrary object to a string, if possible. Returns an empty string
		if not possible.
	]]
	var v = asValueOrNull(obj)
	if not v:
		v = ""
	return v
}

func asObject(obj as dynamic?) static as StringObject?
{
	var value = asValueOrNull(obj)
	if not value:
		return null
	return wrapValue(value)
}

func forObjectInformation(obj as object) static as string
{
	description [[
		Creates a string that provides information about the contents and structure of
		the given object.
	]]
	IFDEF "target_node_js" {
		return lang "js" (obj) as string {{{ require("node:util").format("%O", obj) }}}
	}
	ELSE IFDEF "target_swift" {
		return lang "swift" (obj) as string {{{ Swift.String(describing: obj) }}}
	}
	ELSE {
		var v = asValueOrNull(obj)
		if not v:
			v = "unknown"
		return v
	}
}

func safeString(str as string?) static as string
{
	description [[
		Returns a safe string (= make sure it is not null). Essentially returns a valid
		non-null empty string if the value is null. Otherwise returns the string itself.
	]]
	if not str:
		return ""
	return str
}

func isEmpty(str as string?) static as bool #nullcheck
{
	description [[
		Checks if a string is empty (ie., either the object is a null pointer or the
		length of the string is less than one character).
	]]
	if not str:
		return true
	IFDEF "target_sushi" {
		if lang "lua" as int {{{ _util:get_string_length(str) }}} < 1:
			return true
	}
	ELSE {
		if getLength(str) < 1:
			return true
	}
	return false
}

func isNotEmpty(str as string?) static as bool #notnullcheck
{
	description [[
		Checks that the given string is not empty. Returns true if the string is not
		empty, false if the string is empty.
	]]
	return not isEmpty(str)
}

func forBuffer(data as buffer, encoding as string) static throws Exception as string
{
	description [[
		Constructs a new string, given a buffer of bytes and the name of the encoding.
		Supported encodings: UTF8, UCS2 and ASCII
	]]
	if equalsIgnoreCase("UTF8", encoding) || equalsIgnoreCase("UTF-8", encoding):
		return forUTF8Buffer(data)
	if equalsIgnoreCase("UCS2", encoding) || equalsIgnoreCase("UCS-2", encoding):
		return forUCS2Buffer(data)
	if equalsIgnoreCase("ASCII", encoding):
		return forASCIIBuffer(data)
	Error.throw("unsupportedCharacterEncoding", encoding)
}

IFDEF "target_dotnet_cs"
{
	func getDataLength(data as buffer) private static as int #used
	{
		var v as int
		lang "cs" (v, data) {{{
			v = data.Length;
			while(v > 0) {
				if(data[v-1] == 0) {
					v--;
				}
				else {
					break;
				}
			}
		}}}
		return v
	}
}

func forASCIIBuffer(data as buffer) static as string
{
	description [[
		Constructs a new string for a buffer of bytes, encoded using the ASCII character
		set.
	]]
	IFDEF "target_dotnet_cs" {
		return safeString(lang "cs" (data) as string {{{ System.Text.Encoding.ASCII.GetString(data, 0, getDataLength(data)) }}})
	}
	ELSE IFDEF "target_objc" {
		return safeString(lang "objc" (data) as string? {{{ [[NSString alloc] initWithData:data encoding:NSASCIIStringEncoding] }}})
	}
	ELSE IFDEF "target_java" {
		var v as string?
		lang "java" (data) {{{
			try {
				v = new java.lang.String(data, "US-ASCII");
			}
			catch(java.lang.Exception e) {
				throw new RuntimeException(e);
			}
		}}}
		return safeString(v)
	}
	ELSE IFDEF "target_js" {
		var sb = new StringBuilder()
		var uintArray = lang "js" (data) as array<uint8> {{{ new Uint8Array(data) }}}
		for(var i = 0 ; i < sizeof uintArray ; i++) {
			var str = lang "js" as string? {{{ String.fromCharCode(uintArray[i]) }}}
			if str:
				sb.appendString(str)
		}
		return sb.toString()
	}
	ELSE IFDEF "target_kotlin" {
		return safeString(lang "kotlin" (data) as string? {{{ data!!.toByteArray()?.toString(kotlin.text.Charsets.US_ASCII) }}})
	}
	ELSE IFDEF "target_swift" {
		return safeString(lang "swift" (data) as string? {{{ Swift.String(data: data.data, encoding: Swift.String.Encoding.ascii) }}})
	}
	ELSE IFDEF "target_sushi" {
		return safeString(lang "lua" (data) as string? {{{ _util:convert_buffer_ascii_to_string(data) }}})
	}
	ELSE {
		var sb = new StringBuilder()
		var sz = sizeof data
		for(var n = 0 ; n < sz ; n++):
			sb.appendCharacter(data[n] as! char)
		return sb.toString()
	}
}

func forUTF8Buffer(data as buffer) static as string
{
	description [[
		Constructs a new string for a buffer of bytes, encoded using the UTF8 character
		encoding.
	]]
	IFDEF "target_dotnet_cs" {
		return safeString(lang "cs" (data) as string {{{ System.Text.Encoding.UTF8.GetString(data, 0, getDataLength(data)) }}})
	}
	ELSE IFDEF "target_objc" {
		return safeString(lang "objc" (data) as string {{{ [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding] }}})
	}
	ELSE IFDEF "target_java" {
		var v as string?
		lang "java" (data) {{{
			try {
				v = new java.lang.String(data, "UTF-8");
			}
			catch(java.lang.Exception e) {
				throw new RuntimeException(e);
			}
		}}}
		return safeString(v)
	}
	ELSE IFDEF "target_kotlin" {
		return safeString(lang "kotlin" (data) as string? {{{ kotlin.text.String(data!!.toByteArray(), kotlin.text.Charsets.UTF_8) }}})
	}
	ELSE IFDEF "target_swift" {
		return safeString(lang "swift" (data) as string? {{{ Swift.String(data: data.data, encoding: Swift.String.Encoding.utf8) }}})
	}
	ELSE IFDEF "target_sushi" {
		return safeString(lang "lua" (data) as string {{{ _util:convert_buffer_to_string(data) }}})
	}
	ELSE IFDEF "target_js" {
		return safeString(lang "js" (data) as string {{{ new TextDecoder().decode(data) }}})
	}
	ELSE {
		var sb = new StringBuilder()
		var ci = CharacterIteratorForBuffer.forBuffer(data)
		ci.moveToNextChar()
		loop {
			if ci.hasEnded():
				break
			var c = ci.getCurrentChar()
			sb.appendCharacter(c)
			ci.moveToNextChar()
		}
		return sb.toString()
	}
}

func forUCS2Buffer(data as buffer) static as string
{
	description [[
		Constructs a new string for a buffer of bytes, encoded using the UCS2 character
		encoding.
	]]
	IFDEF "target_java" {
		var v as string?
		lang "java" (data) {{{
			try {
				v = new java.lang.String(data, "UCS-2");
			}
			catch(java.lang.Exception e) {
				throw new RuntimeException(e);
			}
		}}}
		return safeString(v)
	}
	ELSE IFDEF "target_objc" {
		return safeString(lang "objc" (data) as string {{{ [[NSString alloc] initWithData:data encoding:NSUnicodeStringEncoding] }}})
	}
	ELSE IFDEF "target_js" {
		return safeString(lang "js" (data) as string? {{{ data.toString("ucs2") }}})
	}
	ELSE IFDEF "target_swift" {
		return safeString(lang "swift" (data) as string? {{{ Swift.String(data: data.data, encoding: Swift.String.Encoding.unicode) }}})
	}
	ELSE {
		nop data
		ERROR NOT_IMPLEMENTED
	}
}

func forCharArray(chars as array<char>, offset as int, count as int) static as string
{
	description [[
		Constructs a new string for an array or characters.
	]]
	IFDEF "target_dotnet_cs" {
		return safeString(lang "cs" (chars, offset, count) as string {{{ new string(chars, offset, count) }}})
	}
	ELSE IFDEF "target_java" {
		return safeString(lang "java" (chars, offset, count) as string {{{ new java.lang.String(chars, offset, count) }}})
	}
	ELSE IFDEF "target_node_js" {
		var str = ""
		lang "js" (chars, offset, count) {{{
			let index = 0;
			for(const cc of chars) { 
				if (index > count) {
					break;
				}
				if (index >= offset) {
					str += String.fromCharCode(cc);
				}
				index++;
			}
		}}}
		return str
	}
	ELSE IFDEF "target_js" {
		var str as string?
		lang "js" (chars, offset, count) {{{
			if(offset < chars.length && count <= chars.length && offset < count) {
				str = "";
				for(var ind = offset; ind < count; ind++) {
					str += chars[ind];
				}
			}
		}}}
		return safeString(str)
	}
	ELSE IFDEF "target_kotlin" {
		return safeString(lang "kotlin" (chars, offset, count) as string? {{{ kotlin.text.String(chars, offset, count) }}})
	}
	ELSE {
		var sb = new StringBuilder()
		var sz = sizeof chars
		for(var n = 0 ; n < count && n + offset < sz ; n++):
			sb.appendCharacter(chars[n + offset])
		return sb.toString()
	}
}

func forBoolean(vv as bool) static as string
{
	description [[
		Converts a boolean value to a string. The resulting string will be either "true"
		or "false", depending of the boolean value.
	]]
	if vv == true:
		return "true"
	return "false"
}

func forInteger(vv as int) static as string
{
	description [[
		Converts an integer value to a string. The resulting string will be a string
		representation of the value of the integer using the "base-10" decimal notation.
	]]
	IFDEF "target_dotnet_cs" {
		return safeString(lang "cs" (vv) as string {{{ vv.ToString() }}})
	}
	ELSE IFDEF "target_objc" {
		return safeString(lang "objc" (vv) as string {{{ [NSString stringWithFormat:@"%d", vv] }}})
	}
	ELSE IFDEF "target_java" {
		return safeString(lang "java" (vv) as string {{{ java.lang.String.valueOf(vv) }}})
	}
	ELSE IFDEF "target_js" {
		return safeString(lang "js" (vv) as string? {{{ (~~vv).toString() }}})
	}
	ELSE IFDEF "target_kotlin" {
		return safeString(lang "kotlin" (vv) as string? {{{ vv.toString() }}})
	}
	ELSE IFDEF "target_sushi" {
		return safeString(lang "lua" (vv) as string {{{ _util:create_decimal_string_for_integer(vv) }}})
	}
	ELSE IFDEF "target_stdlua" {
		return safeString(lang "lua" (vv) as string {{{ tostring(vv) }}})
	}
	ELSE IFDEF "target_swift" {
		return lang "swift" (vv) as string {{{ Swift.String(vv) }}}
	}
	ELSE {
		nop vv
		ERROR NOT_IMPLEMENTED
	}
}

func forLongInteger(vv as long) static as string
{
	description [[
		Converts a long integer value to a string. The resulting string will be a string
		representation of the value of the integer using the "base-10" decimal notation.
	]]
	IFDEF "target_dotnet_cs" {
		return safeString(lang "cs" (vv) as string {{{ vv.ToString() }}})
	}
	ELSE IFDEF "target_objc" {
		return safeString(lang "objc" (vv) as string {{{ [NSString stringWithFormat:@"%d", vv] }}})
	}
	ELSE IFDEF "target_java" {
		return safeString(lang "java" (vv) as string {{{ java.lang.String.valueOf(vv) }}})
	}
	ELSE IFDEF "target_js" {
		return safeString(lang "js" (vv) as string? {{{ parseInt(vv).toString() }}})
	}
	ELSE IFDEF "target_kotlin" {
		return safeString(lang "kotlin" (vv) as string? {{{ vv.toString() }}})
	}
	ELSE IFDEF "target_sushi" {
		return safeString(lang "lua" (vv) as string {{{ _util:create_decimal_string_for_integer(vv) }}})
	}
	ELSE IFDEF "target_stdlua" {
		return safeString(lang "lua" (vv) as string {{{ tostring(vv) }}})
	}
	ELSE IFDEF "target_swift" {
		return lang "swift" (vv) as string {{{ Swift.String(vv) }}}
	}
	ELSE {
		nop vv
		ERROR NOT_IMPLEMENTED
	}
}

func forIntegerWithPadding(vv as int, length as int, paddingString as string? = null) static as string
{
	description [[
		Converts an integer value to a string while ensuring that the length of the
		resulting string will reach or exceed the given "length". If the length of the
		string naturally is less than the given length, then "padding" characters will
		be prepended to the string in order to make the string long enough. The default
		padding character is "0", but can be customized with the "paddingString"
		parameter. eg. String.forIntegerWithPadding(9, 3, "0") would yield "009". eg.
		String.forIntegerWithPadding(10, 4, " ") would yield " 10".
	]]
	var r = forInteger(vv)
	var ll = getLength(r)
	if ll >= length:
		return r
	var ps = paddingString
	if ps == null:
		ps = "0"
	var sb = new StringBuilder()
	var n as int
	for(n = 0 ; n < length - ll ; n++):
		sb.appendString(ps)
	sb.appendString(r)
	return sb.toString()
}

func padWithZero(value as string, length as int) private static as string #used
{
	if length < 1:
		return value
	var v = value
	while getLength(v) < length:
		v = "0" .. v
	return v
}

func forIntegerHex(vv as int, minlength as int = 0) static as string
{
	description [[
		Converts an integer value to a string using the "base-16" or hexadecimal
		notation.
	]]
	IFDEF "target_dotnet_cs" {
		return padWithZero(lang "cs" (vv) as string {{{ vv.ToString("x") }}}, minlength)
	}
	ELSE IFDEF "target_objc" {
		return padWithZero(lang "objc" (vv) as string {{{ [NSString stringWithFormat:@"%X", vv] }}}, minlength)
	}
	ELSE IFDEF "target_java" {
		return padWithZero(lang "java" (vv) as string {{{ java.lang.Integer.toHexString(vv) }}}, minlength)
	}
	ELSE IFDEF "target_js" {
		return padWithZero(lang "js" (vv) as string {{{ (~~vv).toString(16) }}}, minlength)
	}
	ELSE IFDEF "target_kotlin" {
		return padWithZero(lang "kotlin" (vv) as string {{{ vv.toString(16) }}}, minlength)
	}
	ELSE IFDEF "target_swift" {
		return padWithZero(lang "swift" (vv) as string {{{ Swift.String(format:"%x", vv) }}}, minlength)
	}
	ELSE IFDEF "target_sushi" {
		return padWithZero(lang "lua" (vv) as string {{{ _util:create_hex_string_for_integer(vv) }}}, minlength)
	}
	ELSE {
		nop vv
		nop minlength
		ERROR NOT_IMPLEMENTED
	}
}

func forUnsignedInteger64Hex(vv as uint64, minlength as int = 0) static as string
{
	description [[
		Converts an long integer value to a string using the "base-16" or hexadecimal
		notation.
	]]
	IFDEF "target_dotnet_cs" {
		return padWithZero(lang "cs" (vv) as string {{{ vv.ToString("x") }}}, minlength)
	}
	ELSE IFDEF "target_objc" {
		return padWithZero(lang "objc" (vv) as string {{{ [NSString stringWithFormat:@"%X", vv] }}}, minlength)
	}
	ELSE IFDEF "target_java" {
		return padWithZero(lang "java" (vv) as string {{{ java.lang.Long.toHexString(vv) }}}, minlength)
	}
	ELSE IFDEF "target_js" {
		return padWithZero(lang "js" (vv) as string {{{ vv.toString(16) }}}, minlength)
	}
	ELSE IFDEF "target_kotlin" {
		return padWithZero(lang "kotlin" (vv) as string {{{ vv.toString(16) }}}, minlength)
	}
	ELSE IFDEF "target_swift" {
		return padWithZero(lang "swift" (vv) as string {{{ Swift.String(format:"%lx", vv) }}}, minlength)
	}
	ELSE IFDEF "target_sushi" {
		return padWithZero(lang "lua" (vv) as string {{{ _util:create_hex_string_for_integer(vv) }}}, minlength)
	}
	ELSE {
		nop vv
		nop minlength
		ERROR NOT_IMPLEMENTED
	}
}

func forIntegerOctal(vv as int) static as string
{
	description [[
		Converts an integer value to a string using the octal notation.
	]]
	IFDEF "target_dotnet_cs" {
		return safeString(lang "cs" (vv) as string {{{ System.Convert.ToString(vv, 8) }}})
	}
	ELSE IFDEF "target_objc" {
		return safeString(lang "objc" (vv) as string {{{ [NSString stringWithFormat:@"%o", vv] }}})
	}
	ELSE IFDEF "target_java" {
		return safeString(lang "java" (vv) as string {{{ java.lang.Integer.toOctalString(vv) }}})
	}
	ELSE IFDEF "target_js" {
		return safeString(lang "js" (vv) as string? {{{ (~~vv).toString(8) }}})
	}
	ELSE IFDEF "target_kotlin" {
		return safeString(lang "kotlin" (vv) as string? {{{ vv.toString(8) }}})
	}
	ELSE IFDEF "target_swift" {
		return lang "swift" (vv) as string {{{ Swift.String(format:"%o", vv) }}}
	}
	ELSE IFDEF "target_sushi" {
		return safeString(lang "lua" (vv) as string {{{ _util:create_octal_string_for_integer(vv) }}})
	}
	ELSE {
		nop vv
		ERROR NOT_IMPLEMENTED
	}
}

func forIntegerBinary(vv as int) static as string
{
	description [[
		Converts an integer value to a string using the binary notation.
	]]
	IFDEF "target_dotnet_cs" {
		return safeString(lang "cs" (vv) as string {{{ System.Convert.ToString(vv, 2) }}})
	}
	ELSE IFDEF "target_java" {
		return safeString(lang "java" (vv) as string {{{ java.lang.Integer.toBinaryString(vv) }}})
	}
	ELSE IFDEF "target_js" {
		return safeString(lang "js" (vv) as string? {{{ (~~vv).toString(2) }}})
	}
	ELSE IFDEF "target_kotlin" {
		return safeString(lang "kotlin" (vv) as string? {{{ vv.toString(2) }}})
	}
	ELSE IFDEF "target_swift" {
		return lang "swift" (vv) as string {{{ Swift.String(vv, radix: 2) }}}
	}
	ELSE {
		nop vv
		ERROR NOT_IMPLEMENTED
	}
}

func forBufferHex(buffer as buffer) static as string
{
	description [[
		Converts a buffer of bytes to a string using the "base-16" or hexadecimal
		notation.
	]]
	var size = Buffer.getSize(buffer)
	var sb = new StringBuilder()
	var p = 0
	while p < size {
		var s = forIntegerHex(Buffer.getByte(buffer, p))
		if getLength(s) < 2:
			sb.appendCharacter('0')
		sb.appendString(s)
		p++
	}
	return sb.toString()
}

func forCharacter(vv as char) static as string
{
	description [[
		Converts a character to a string. The result will be a single-character string.
	]]
	IFDEF "target_dotnet_cs" {
		return lang "cs" (vv) as string {{{ new string(vv, 1) }}}
	}
	ELSE IFDEF "target_objc" {
		var v as string?
		lang "objc" (vv) {{{
			UInt32 h = (UInt32)vv;
			v = [[NSString alloc] initWithBytes:&h length:sizeof(h) encoding:NSUTF32LittleEndianStringEncoding];
		}}}
		return safeString(v)
	}
	ELSE IFDEF "target_java" {
		return lang "java" (vv) as string {{{ java.lang.String.valueOf(vv) }}}
	}
	ELSE IFDEF "target_js" {
		return lang "js" (vv) as string {{{ String.fromCharCode(vv) }}}
	}
	ELSE IFDEF "target_sushi" {
		if vv < 0x80 {
			return lang "lua" (vv) as string {{{ _util:create_string_for_byte(vv) }}}
		}
		else if vv < 0x800 {
			var v1 = 0xC0 | (vv >> 6)
			var v2 = 0x80 | (vv & 0x3F)
			return lang "lua" as string {{{ _util:create_string_for_byte(v1) .. _util:create_string_for_byte(v2) }}}
		}
		else if vv < 0x10000 {
			var v1 = 0xE0 | (vv >> 12)
			var v2 = 0x80 | ((vv >> 6) & 0x3F)
			var v3 = 0x80 | (vv & 0x3F)
			return lang "lua" as string {{{ _util:create_string_for_byte(v1) .. _util:create_string_for_byte(v2) .. _util:create_string_for_byte(v3) }}}
		}
		else {
			var v1 = 0xF0 | (vv >> 18)
			var v2 = 0x80 | ((vv >> 12) & 0x3F)
			var v3 = 0x80 | ((vv >> 6) & 0x3F)
			var v4 = 0x80 | (vv & 0x3F)
			return lang "lua" as string {{{ _util:create_string_for_byte(v1) .. _util:create_string_for_byte(v2) .. _util:create_string_for_byte(v3) .. _util:create_string_for_byte(v4) }}}
		}
	}
	ELSE IFDEF "target_stdlua" {
		if vv < 0x80 {
			return lang "lua" (vv) as string {{{ string.char(vv) }}}
		}
		else if vv < 0x800 {
			var v1 = 0xC0 | (vv >> 6)
			var v2 = 0x80 | (vv & 0x3F)
			return lang "lua" as string {{{ string.char(v1) .. string.char(v2) }}}
		}
		else if vv < 0x10000 {
			var v1 = 0xE0 | (vv >> 12)
			var v2 = 0x80 | ((vv >> 6) & 0x3F)
			var v3 = 0x80 | (vv & 0x3F)
			return lang "lua" as string {{{ string.char(v1) .. string.char(v2) .. string.char(v3) }}}
		}
		else {
			var v1 = 0xF0 | (vv >> 18)
			var v2 = 0x80 | ((vv >> 12) & 0x3F)
			var v3 = 0x80 | ((vv >> 6) & 0x3F)
			var v4 = 0x80 | (vv & 0x3F)
			return lang "lua" as string {{{ string.char(v1) .. string.char(v2) .. string.char(v3) .. string.char(v4) }}}
		}
	}
	ELSE IFDEF "target_kotlin" {
		return safeString(lang "kotlin" (vv) as string? {{{ vv.toString() }}})
	}
	ELSE IFDEF "target_swift" {
		return lang "swift" (vv) as string {{{ Swift.String(Unicode.Scalar(vv) ?? Unicode.Scalar(0)) }}}
	}
	ELSE {
		nop vv
		ERROR NOT_IMPLEMENTED
	}
}

func forFloat(vv as float) static as string
{
	description [[
		Converts a floating point value to a string.
	]]
	IFDEF "target_objc" {
		return safeString(lang "objc" (vv) as string {{{ [NSString stringWithFormat:@"%f", vv] }}})
	}
	ELSE IFDEF "target_java" {
		return lang "java" (vv) as string {{{ java.lang.String.valueOf(vv) }}}
	}
	ELSE IFDEF "target_dotnet_cs" {
		return lang "cs" (vv) as string {{{ vv.ToString() }}}
	}
	ELSE IFDEF "target_js" {
		return safeString(lang "js" (vv) as string? {{{ vv.toString() }}})
	}
	ELSE IFDEF "target_kotlin" {
		return safeString(lang "kotlin" (vv) as string? {{{ vv.toString() }}})
	}
	ELSE IFDEF "target_sushi" {
		return safeString(lang "lua" (vv) as string {{{ _util:create_string_for_float(vv) }}})
	}
	ELSE IFDEF "target_stdlua" {
		return safeString(lang "lua" (vv) as string {{{ tostring(vv) }}})
	}
	ELSE IFDEF "target_swift" {
		return lang "swift" (vv) as string {{{ vv.description }}}
	}
	ELSE {
		nop vv
		ERROR NOT_IMPLEMENTED
	}
}

func forDouble(vv as double) static as string
{
	description [[
		Converts a double-precision floating point value to a string.
	]]
	IFDEF "target_objc" {
		return safeString(lang "objc" (vv) as string {{{ [NSString stringWithFormat:@"%f", vv] }}})
	}
	ELSE IFDEF "target_java" {
		return safeString(lang "java" (vv) as string {{{ new java.math.BigDecimal(java.lang.Double.toString(vv)).toPlainString() }}})
	}
	ELSE IFDEF "target_dotnet_cs" {
		var str = lang "cs" (vv) as string {{{ vv.ToString("0." + new string('#', 339)) }}}
		if getIndexOfCharacter(str, '.') < 0:
			str = str .. ".0"
		return str
	}
	ELSE IFDEF "target_js" {
		return safeString(lang "js" (vv) as string? {{{ vv.toString() }}})
	}
	ELSE IFDEF "target_kotlin" {
		return safeString(lang "kotlin" (vv) as string? {{{ java.math.BigDecimal(vv.toString()).toPlainString() }}})
	}
	ELSE IFDEF "target_sushi" {
		return safeString(lang "lua" (vv) as string {{{ _util:create_string_for_float(vv) }}})
	}
	ELSE IFDEF "target_stdlua" {
		return safeString(lang "lua" (vv) as string {{{ tostring(vv) }}})
	}
	ELSE IFDEF "target_swift" {
		return lang "swift" (vv) as string {{{ vv.description }}}
	}
	ELSE {
		nop vv
		ERROR NOT_IMPLEMENTED
	}
}

func forDoubleWithDecimals(vv as double, decimals as int) static as string
{
	IFDEF "target_objc" {
		var format = "%." .. forInteger(decimals) .. "f"
		return safeString(lang "objc" (format, vv) as string {{{ [NSString stringWithFormat:format, vv] }}})
	}
	ELSE IFDEF "target_java" {
		var format = "%." .. forInteger(decimals) .. "f"
		return safeString(lang "java" (format, vv) as string {{{ String.format(format, vv) }}})
	}
	ELSE IFDEF "target_dotnet_cs" {
		var format = StringBuilder.forString("{0:0.")
		for(var i = 0 ; i < decimals ; i++):
			format.appendString("0")
		format.appendString("}")
		return safeString(lang "cs" (format, vv) as string {{{ String.Format(format, vv) }}})
	}
	ELSE IFDEF "target_js" {
		return safeString(lang "js" (vv, decimals) as string? {{{ vv.toFixed(decimals) }}})
	}
	ELSE IFDEF "target_kotlin" {
		var format = "%." .. forInteger(decimals) .. "f"
		return safeString(lang "kotlin" (format, vv) as string? {{{ String.format(format, vv) }}})
	}
	ELSE IFDEF "target_sushi" {
		return safeString(lang "lua" (vv, decimals) as string {{{ _util:create_string_for_double_with_decimals(vv, decimals) }}})
	}
	ELSE IFDEF "target_swift" {
		var format = "%." .. forInteger(decimals) .. "f"
		return lang "swift" (format, vv) as string {{{ Swift.String(format: format, vv) }}}
	}
	ELSE {
		nop vv
		nop decimals
		ERROR NOT_IMPLEMENTED
	}
}

func toUTF8Buffer(str as string) static as buffer
{
	description [[
		Converts a string to a buffer of bytes, encoded using the UTF8 encoding.
	]]
	IFDEF "target_dotnet_cs" {
		return lang "cs" (str) as buffer {{{ System.Text.Encoding.UTF8.GetBytes(str) }}}
	}
	ELSE IFDEF "target_java" {
		return lang "java" (str) as buffer {{{ str.getBytes(java.nio.charset.StandardCharsets.UTF_8) }}}
	}
	ELSE IFDEF "target_objc" {
		var v = lang "objc" (str) as buffer? {{{ [[str dataUsingEncoding:NSUTF8StringEncoding] mutableCopy] }}}
		if not v:
			Error.throw("failedToConvertStringToUTF8Buffer", str)
		return v
	}
	ELSE IFDEF "target_kotlin" {
		var v = lang "kotlin" (str) as buffer? {{{ str.toByteArray(kotlin.text.charset(kotlin.text.Charsets.UTF_8))?.toUByteArray() }}}
		if not v:
			Error.throw("failedToConvertStringToUTF8Buffer", str)
		return v
	}
	ELSE IFDEF "target_swift" {
		return lang "swift" (str) as buffer {{{ BufferValue.forData(Foundation.Data(str.utf8)) }}}
	}
	ELSE IFDEF "target_stdlua" {
		var v = lang "lua" as buffer {{{ {} }}}
		lang "lua" (str) {{{
			for i=1, #str do
				v[#v + 1] = string.byte(str, i)
			end
		}}}
		return v
	}
	ELSE IFDEF "target_sushi" {
		return lang "lua" (str) as buffer {{{ _util:convert_string_to_buffer(str) }}}
	}
	ELSE IFDEF "target_js" {
		var bytes = lang "js" as array<uint8> {{{ [] }}}
		lang "js" (str) {{{
			for(var i = 0; i < str.length; i++) {
				var cc = str.charCodeAt(i);
				if(cc < 0x80) {
					bytes.push(cc);
				}
				else if(cc < 0x800) {
					bytes.push(0xc0 | (cc >> 6));
					bytes.push(0x80 | (cc & 0x3f));
				}
				else if(cc < 0xd800 || cc >= 0xe000) {
					bytes.push(0xe0 | (cc >> 12));
					bytes.push(0x80 | ((cc >> 6) & 0x3f));
					bytes.push(0x80 | (cc & 0x3f));
				}
				else {
					i++;
					cc = (((cc & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff)) + 0x10000;
					bytes.push(0xf0 | (cc >> 18));
					bytes.push(0x80 | ((cc >> 12) & 0x3f));
					bytes.push(0x80 | ((cc >> 6) & 0x3f));
					bytes.push(0x80 | (cc & 0x3f));
				}
			}
		}}}
		var bsz = sizeof bytes
		var bb = Buffer.allocate(bsz)
		var n as int
		for(n = 0 ; n < bsz ; n++):
			Buffer.setByte(bb, n, bytes[n])
		return bb
	}
	ELSE {
		nop str
		ERROR NOT_IMPLEMENTED
	}
}

func getLength(str as string) static as int
{
	description [[
		Gets the length of a string, representing the number of characters composing the
		string (note: This is not the same as the number of bytes allocated to hold the
		memory for the string).
	]]
	IFDEF "target_dotnet_cs" {
		return lang "cs" (str) as int {{{ str.Length }}}
	}
	ELSE IFDEF "target_objc" {
		return lang "objc" (str) as int {{{ [str length] }}}
	}
	ELSE IFDEF "target_java" {
		return lang "java" (str) as int {{{ str.length() }}}
	}
	ELSE IFDEF "target_js" {
		return lang "js" (str) as int {{{ str.length }}}
	}
	ELSE IFDEF "target_kotlin" {
		return lang "kotlin" (str) as int {{{ str.length }}}
	}
	ELSE IFDEF "target_swift" {
		return lang "swift" (str) as int {{{ str.count }}}
	}
	ELSE IFDEF "target_sushi" {
		return lang "lua" (str) as int {{{ _util:get_utf8_character_count(str) }}}
	}
	ELSE {
		var v = 0
		foreach c #used in iterate(str):
			v++
		return v
	}
}

func appendString(str1 as string?, str2 as string?) static as string
{
	description [[
		Appends a string "str2" to the end of another string "str1". Either one of the
		values may be null: If "str1" is null, the value of "str2" is returned, and if
		"str2" is null, the value of "str1" is returned.
	]]
	if str1 == null {
		if str2:
			return str2
		return ""
	}
	if str2 == null:
		return str1
	IFDEF "target_dotnet_cs" {
		return lang "cs" as string {{{ System.String.Concat(str1, str2) }}}
	}
	ELSE IFDEF "target_objc" {
		var v = lang "objc" as string? {{{ [str1 stringByAppendingString:str2] }}}
		if not v:
			v = ""
		return v
	}
	ELSE IFDEF "target_java" {
		var v = lang "java" as string? {{{ str1.concat(str2 != null ? str2 : "") }}}
		if not v:
			v = ""
		return v
	}
	ELSE IFDEF "target_js" {
		var v = lang "js" as string? {{{ str1.concat(str2) }}}
		if not v:
			v = ""
		return v
	}
	ELSE IFDEF "target_kotlin" {
		var v = lang "kotlin" as string? {{{ str1.plus(str2) }}}
		if not v:
			v = ""
		return v
	}
	ELSE IFDEF "target_swift" {
		return lang "swift" as string {{{ str1! + str2! }}}
	}
	ELSE IFDEF "target_lua" {
		var v = lang "lua" as string? {{{ str1 .. str2 }}}
		if not v:
			v = ""
		return v
	}
	ELSE {
		nop str1
		nop str2
		ERROR NOT_IMPLEMENTED
	}
}

func appendInteger(str as string?, intvalue as int) static as string
{
	description [[
		Appends an integer value "intvalue" to the end of string "str". If the original
		string is null, then a new string is returned, representing only the integer
		value.
	]]
	return appendString(str, forInteger(intvalue))
}

func appendCharacter(str as string?, charvalue as char) static as string
{
	description [[
		Appends a character value "charvalue" to the end of string "str". If the
		original string is null, then a new string is returned, representing only the
		character value.
	]]
	return appendString(str, forCharacter(charvalue))
}

func appendFloat(str as string?, floatvalue as float) static as string
{
	description [[
		Appends a floating point value "floatvalue" to the end of string "str". If the
		original string is null, then a new string is returned, representing only the
		floating point value.
	]]
	return appendString(str, forFloat(floatvalue))
}

func appendDouble(str as string?, doublevalue as double) static as string
{
	description [[
		Appends a double-precision floating point value "doublevalue" to the end of
		string "str". If the original string is null, then a new string is returned,
		representing only the floating point value.
	]]
	return appendString(str, forDouble(doublevalue))
}

func appendBoolean(str as string?, boolvalue as bool) static as string
{
	description [[
		Appends a boolean value "boolvalue" to the end of string "str". If the original
		string is null, then a new string is returned, representing only the boolean
		value.
	]]
	return appendString(str, forBoolean(boolvalue))
}

func toLowerCase(str as string) static as string
{
	description [[
		Converts all characters of a string to lowercase.
	]]
	IFDEF "target_dotnet_cs" {
		return lang "cs" (str) as string {{{ str.ToLower() }}}
	}
	ELSE IFDEF "target_objc" {
		return safeString(lang "objc" (str) as string? {{{ [str lowercaseString] }}})
	}
	ELSE IFDEF "target_java" {
		return safeString(lang "java" (str) as string? {{{ str.toLowerCase() }}})
	}
	ELSE IFDEF "target_js" {
		return safeString(lang "js" (str) as string? {{{ str.toLowerCase() }}})
	}
	ELSE IFDEF "target_kotlin" {
		return safeString(lang "kotlin" (str) as string? {{{ str.toLowerCase() }}})
	}
	ELSE IFDEF "target_sushi" {
		return safeString(lang "lua" (str) as string? {{{ _util:change_string_to_lowercase(str) }}})
	}
	ELSE IFDEF "target_stdlua" {
		return safeString(lang "lua" (str) as string? {{{ string.lower(str) }}})
	}
	ELSE IFDEF "target_swift" {
		return lang "swift" (str) as string {{{ str.lowercased() }}}
	}
	ELSE {
		nop str
		ERROR NOT_IMPLEMENTED
	}
}

func toUpperCase(str as string) static as string
{
	description [[
		Converts all characters of a string to uppercase.
	]]
	IFDEF "target_dotnet_cs" {
		return lang "cs" (str) as string {{{ str.ToUpper() }}}
	}
	ELSE IFDEF "target_objc" {
		return safeString(lang "objc" (str) as string? {{{ [str uppercaseString] }}})
	}
	ELSE IFDEF "target_java" {
		return safeString(lang "java" (str) as string? {{{ str.toUpperCase() }}})
	}
	ELSE IFDEF "target_js" {
		return safeString(lang "js" (str) as string? {{{ str.toUpperCase() }}})
	}
	ELSE IFDEF "target_kotlin" {
		return safeString(lang "kotlin" (str) as string? {{{ str.toUpperCase() }}})
	}
	ELSE IFDEF "target_sushi" {
		return safeString(lang "lua" (str) as string? {{{ _util:change_string_to_uppercase(str) }}})
	}
	ELSE IFDEF "target_stdlua" {
		return safeString(lang "lua" (str) as string? {{{ string.upper(str) }}})
	}
	ELSE IFDEF "target_swift" {
		return lang "swift" (str) as string {{{ str.uppercased() }}}
	}
	ELSE {
		nop str
		ERROR NOT_IMPLEMENTED
	}
}

func capitalize(str as string) static as string
{
	description [[
		Ensures that the first letter of the string is in uppercase.
	]]
	var c = getChar(str, 0)
	if Character.isLowercaseAlpha(c) == false:
		return str
	return forCharacter(Character.toUppercase(c)) .. getEndOfString(str, 1)
}

func getChar(str as string, index as int) static as char
{
	description [[
		Gets a character with the specified index "index" from the given string.
	]]
	if index < 0:
		return 0 as! char
	IFDEF "target_dotnet_cs" {
		return lang "cs" (str, index) as char {{{ str == null || index < 0 || index >= str.Length ? (char)0 : str[index] }}}
	}
	ELSE IFDEF "target_objc" {
		return lang "objc" (str, index) as char {{{ str == nil || index < 0 || index >= [str length] ? 0 : [str characterAtIndex:index] }}}
	}
	ELSE IFDEF "target_java" {
		return lang "java" (str, index) as char {{{ str == null || index < 0 || index >= str.length() ? (char)0 : str.charAt(index) }}}
	}
	ELSE IFDEF "target_js" {
		return lang "js" (str, index) as char {{{ str == null || index < 0 || index >= str.length ? 0 : str.charCodeAt(index) }}}
	}
	ELSE IFDEF "target_kotlin" {
		return lang "kotlin" (str, index) as char {{{ if (str == null || index < 0 || index >= str.length) 0.toChar() else str.get(index) }}}
	}
	ELSE IFDEF "target_swift" {
		lang "swift" (str, index) {{{
			let scalar = str[str.index(str.startIndex, offsetBy: index)].unicodeScalars.first
		}}}
		return lang "swift" (str, index) as char {{{ scalar != nil ? scalar!.value : UInt32(0) }}}
	}
	ELSE {
		var n = 0
		foreach c in iterate(str) {
			if n == index:
				return c
			n++
		}
		return 0 as! char
	}
}

func equals(str1 as string?, str2 as string?) static as bool
{
	description [[
		Compares two strings, and returns true if both strings contain exactly the same
		contents (even though they may be represented by different objects). Either of
		the strings may be null, in which case the comparison always results to false.
	]]
	if str1 == null && str2 == null:
		return true
	if str1 == null:
		return false
	if str2 == null:
		return false
	IFDEF "target_dotnet_cs" {
		return lang "cs" as bool {{{ str1.Equals(str2) }}}
	}
	ELSE IFDEF "target_objc" {
		return lang "objc" as bool {{{ [str1 isEqualToString:str2] }}}
	}
	ELSE IFDEF "target_java" {
		return lang "java" as bool {{{ str1.equals(str2) }}}
	}
	ELSE IFDEF "target_js" {
		return lang "js" as bool {{{ str1 === str2 }}}
	}
	ELSE IFDEF "target_kotlin" {
		return lang "kotlin" as bool {{{ str1.equals(str2) }}}
	}
	ELSE IFDEF "target_lua" {
		return lang "lua" as bool {{{ str1 == str2 }}}
	}
	ELSE IFDEF "target_swift" {
		return lang "swift" as bool {{{ str1 == str2 }}}
	}
	ELSE {
		nop str1
		nop str2
		ERROR NOT_IMPLEMENTED
	}
}

func isNotEqual(str1 as string?, str2 as string?) static as bool
{
	description [[
		Compares two strings and returns true if both strings are not equal otherwise
		false.
	]]
	return not equals(str1, str2)
}

func equalsIgnoreCase(str1 as string?, str2 as string?) static as bool
{
	description [[
		Compares two strings for equality (like equals()) while considering uppercase
		and lowercase versions of the same character as equivalent. Eg. strings
		"ThisIsAString" and "thisisastring" would be considered equivalent, and the
		result of comparison would be "true".
	]]
	if str1 == null && str2 == null:
		return true
	if str1 == null:
		return false
	if str2 == null:
		return false
	IFDEF "target_dotnet_cs" {
		return lang "cs" as bool {{{ System.String.Equals(str1, str2, System.StringComparison.OrdinalIgnoreCase) }}}
	}
	ELSE IFDEF "target_objc" {
		return lang "objc" as bool {{{ [str1 caseInsensitiveCompare:str2] == NSOrderedSame }}}
	}
	ELSE IFDEF "target_java" {
		return lang "java" as bool {{{ str1.equalsIgnoreCase(str2) }}}
	}
	ELSE IFDEF "target_js" {
		return lang "js" as bool {{{ str1.toLowerCase() === str2.toLowerCase() }}}
	}
	ELSE IFDEF "target_kotlin" {
		return lang "kotlin" as bool {{{ str1.equals(str2, true) }}}
	}
	ELSE IFDEF "target_swift" {
		return lang "swift" as bool {{{ str1!.caseInsensitiveCompare(str2!) == .orderedSame }}}
	}
	ELSE IFDEF "target_sushi" {
		return 0 == lang "lua" as int {{{ _util:compare_string_ignore_case(str1, str2) }}}
	}
	ELSE {
		return equals(toLowerCase(str1), toLowerCase(str2))
	}
}

func compare(str1 as string?, str2 as string?) static as int
{
	description [[
		Compares two strings, and returns an integer value representing their sorting
		order. The return value 0 indicates that the two strings are equivalent. A
		negative return value (less than 0) indicates that "str1" is less than "str2",
		and a positive return value (greater than 0) indicates that "str1" is greater
		than "str2".
	]]
	if str1 == null && str2 == null:
		return 0
	if str1 == null:
		return -1
	if str2 == null:
		return 1
	IFDEF "target_dotnet_cs" {
		return lang "cs" as int {{{ System.String.Compare(str1, str2, false) }}}
	}
	ELSE IFDEF "target_java" {
		return lang "java" as int {{{ str1.compareTo(str2) }}}
	}
	ELSE IFDEF "target_objc" {
		return lang "objc" as int {{{ ({ NSComparisonResult _r = [str1 compare:str2]; _r == NSOrderedAscending ? -1 : (_r == NSOrderedSame ? 0 : 1); }) }}}
	}
	ELSE IFDEF "target_js" {
		return lang "js" as int {{{ str1.localeCompare(str2) }}}
	}
	ELSE IFDEF "target_kotlin" {
		return lang "kotlin" as int {{{ str1.compareTo(str2) }}}
	}
	ELSE IFDEF "target_swift" {
		var v #mutated = 0
		lang "swift" {{{
			let r = str1!.compare(str2!)
			if(r == .orderedAscending) {
				v = -1
			}
			else if(r == .orderedSame) {
				v = 0
			}
			else if(r == .orderedDescending) {
				v = 1
			}
		}}}
		return v
	}
	ELSE {
		var it1 = iterateAsCharacterIterator(str1)
		var it2 = iterateAsCharacterIterator(str2)
		loop {
			if it1.hasEnded() && it2.hasEnded():
				break
			if it1.hasEnded():
				return -1
			if it2.hasEnded():
				return 1
			var c1 = it1.getNextChar()
			var c2 = it2.getNextChar()
			if c1 < c2:
				return -1
			if c1 > c2:
				return 1
		}
		return 0
	}
}

func compareIgnoreCase(str1 as string?, str2 as string?) static as int
{
	description [[
		Compares strings exactly like compare(), but this method considers uppercase and
		lowercase versions of each character as equivalent.
	]]
	if str1 == null && str2 == null:
		return 0
	if str1 == null:
		return -1
	if str2 == null:
		return 1
	IFDEF "target_dotnet_cs" {
		return lang "cs" as int {{{ System.String.Compare(str1, str2, true) }}}
	}
	ELSE IFDEF "target_java" {
		return lang "java" as int {{{ str1.compareToIgnoreCase(str2) }}}
	}
	ELSE IFDEF "target_objc" {
		return lang "objc" as int {{{ ({ NSComparisonResult _r = [str1 caseInsensitiveCompare:str2]; _r == NSOrderedAscending ? -1 : (_r == NSOrderedSame ? 0 : 1); }) }}}
	}
	ELSE IFDEF "target_js" {
		return lang "js" as int {{{ str1.toLowerCase().localeCompare(str2.toLowerCase()) }}}
	}
	ELSE IFDEF "target_kotlin" {
		return lang "kotlin" as int {{{ str1.compareTo(str2, true) }}}
	}
	ELSE IFDEF "target_swift" {
		var v #mutated = 0
		lang "swift" {{{
			let r = str1!.caseInsensitiveCompare(str2!)
			if(r == .orderedAscending) {
				v = -1
			}
			else if(r == .orderedSame) {
				v = 0
			}
			else if(r == .orderedDescending) {
				v = 1
			}
		}}}
		return v
	}
	ELSE {
		var it1 = iterateAsCharacterIterator(str1)
		var it2 = iterateAsCharacterIterator(str2)
		loop {
			if it1.hasEnded() && it2.hasEnded():
				break
			if it1.hasEnded():
				return -1
			if it2.hasEnded():
				return 1
			var c1 = Character.toLowercase(it1.getNextChar())
			var c2 = Character.toLowercase(it2.getNextChar())
			if c1 < c2:
				return -1
			if c1 > c2:
				return 1
		}
		return 0
	}
}

func getHashCode(str as string) static as int
{
	description [[
		Gets a hash code version of the string as an integer.
	]]
	IFDEF "target_dotnet_cs" {
		return lang "cs" (str) as int {{{ str.GetHashCode() }}}
	}
	ELSE IFDEF "target_objc" {
		return lang "objc" (str) as int {{{ [str hash] }}}
	}
	ELSE IFDEF "target_java" {
		return lang "java" (str) as int {{{ str.hashCode() }}}
	}
	ELSE IFDEF "target_kotlin" {
		return lang "kotlin" (str) as int {{{ str.hashCode() }}}
	}
	ELSE IFDEF "target_swift" {
		return lang "swift" (str) as int {{{ str.hash }}}
	}
	ELSE {
		var hash = 0
		foreach ch in iterate(str) {
			hash = ((hash << 5) - hash) + ch
			hash = hash & hash
		}
		return hash
	}
}

func getIndexOfCharacter(str as string, c as char, start as int = 0) static as int
{
	description [[
		Gets the first index of a given character "c" in string "str", starting from
		index "start".
	]]
	if c == 0:
		return -1
	IFDEF "target_dotnet_cs" {
		return lang "cs" (str, start) as int {{{ str.IndexOf(c, start) }}}
	}
	ELSE IFDEF "target_java" {
		return lang "java" (str, c, start) as int {{{ str.indexOf((int)c, start) }}}
	}
	ELSE IFDEF "target_objc" {
		var v as int
		lang "objc" (str, start) {{{
			NSRange r = [str rangeOfCharacterFromSet:[NSCharacterSet characterSetWithCharactersInString:[NSString stringWithFormat:@"%c", c]] options:0 range:NSMakeRange(start, [str length]-start)];
			if(r.location == NSNotFound) {
				v = -1;
			}
			else {
				v = r.location;
			}
		}}}
		return v
	}
	ELSE IFDEF "target_js" {
		return lang "js" (str, c, start) as int {{{ str.indexOf(String.fromCharCode(c), start) }}}
	}
	ELSE IFDEF "target_kotlin" {
		return lang "kotlin" (str, c, start) as int {{{ str.indexOf(c, start) }}}
	}
	ELSE IFDEF "target_sushi" {
		return lang "lua" (str, c, start) as int {{{ _util:get_index_of_character(str, c, start) }}}
	}
	ELSE IFDEF "target_swift" {
		lang "swift" (str, c, start) {{{
			for (index, character) in str.enumerated() {
				if (index >= start) {
					let scalar = character.unicodeScalars.first
					if (scalar != nil && c == scalar!.value) {
						return index
					}
				}
			}
		}}}
		return -1
	}
	ELSE {
		nop str
		nop c
		nop start
		ERROR NOT_IMPLEMENTED
	}
}

func getIndexOfString(str as string, s as string, start as int = 0) static as int
{
	description [[
		Gets the first index of a given substring "s" in string "str", starting from
		index "start".
	]]
	IFDEF "target_dotnet_cs" {
		return lang "cs" (str, s, start) as int {{{ str.IndexOf(s, start) }}}
	}
	ELSE IFDEF "target_java" {
		return lang "java" (str, s, start) as int {{{ str.indexOf(s, start) }}}
	}
	ELSE IFDEF "target_objc" {
		return lang "objc" (str, s, start) as int {{{ [str rangeOfString:s options:0 range:NSMakeRange(start, [str length]-start)].location }}}
	}
	ELSE IFDEF "target_js" {
		return lang "js" (str, s, start) as int {{{ str.indexOf(s, start) }}}
	}
	ELSE IFDEF "target_kotlin" {
		return lang "kotlin" (str, s, start) as int {{{ str.indexOf(s, start) }}}
	}
	ELSE IFDEF "target_sushi" {
		return lang "lua" (str, s, start) as int {{{ _util:get_index_of_substring(str, s, start) }}}
	}
	ELSE IFDEF "target_swift" {
		if s == "":
			return 0
		var v #mutated = -1
		lang "swift" (str, s, start) {{{
			var ss = str
			if (start > 0) {
				ss = Swift.String(str[str.index(str.startIndex, offsetBy: start)...])
			}
			if let range = ss.range(of: s) {
				v = ss.distance(from: ss.startIndex, to: range.lowerBound) + start
			}
		}}}
		return v
	}
	ELSE {
		nop str
		nop s
		nop start
		ERROR NOT_IMPLEMENTED
	}
}

func getLastIndexOfCharacter(str as string, c as char, start as int = -1) static as int
{
	description [[
		Gets the last index of a given character "c" in string "str", starting from
		index "start".
	]]
	IFDEF "target_dotnet_cs" {
		if start < 0:
			return lang "cs" (str, c) as int {{{ str.LastIndexOf(c) }}}
		return lang "cs" (str, c, start) as int {{{ str.LastIndexOf(c, start) }}}
	}
	ELSE IFDEF "target_java" {
		if start < 0:
			return lang "java" (str, c) as int {{{ str.lastIndexOf((int)c) }}}
		return lang "java" (str, c, start) as int {{{ str.lastIndexOf((int)c, start) }}}
	}
	ELSE IFDEF "target_objc" {
		return lang "objc" (str, c, start) as int {{{ [str rangeOfCharacterFromSet:[NSCharacterSet characterSetWithCharactersInString:[NSString stringWithFormat:@"%c", c]] options:NSBackwardsSearch range:NSMakeRange(0, start < 0 ? [str length] : start)].location }}}
	}
	ELSE IFDEF "target_js" {
		if start <= 0:
			return lang "js" (str, c) as int {{{ str.lastIndexOf(String.fromCharCode(c)) }}}
		return lang "js" (str, c, start) as int {{{ str.lastIndexOf(String.fromCharCode(c), start) }}}
	}
	ELSE IFDEF "target_kotlin" {
		if start <= 0:
			return lang "kotlin" (str, c) as int {{{ str.lastIndexOf(c) }}}
		return lang "kotlin" (str, c, start) as int {{{ str.lastIndexOf(c, start) }}}
	}
	ELSE IFDEF "target_swift" {
		var n as int #mutated
		var cs = forCharacter(c)
		lang "swift" (str, cs) {{{
			let range = str.range(of: cs, options: .backwards)
			if(range == nil) {
				n = -1
			}
			else {
				n = str.distance(from: str.startIndex, to: range!.lowerBound)
			}
		}}}
		if n < start:
			n = -1
		return n
	}
	ELSE {
		var ss = start
		if ss < 0:
			ss = 0
		var ii = getIndexOfCharacter(str, c, ss)
		if ii >= 0 {
			loop {
				var ix = getIndexOfCharacter(str, c, ii + 1)
				if ix < 0:
					break
				ii = ix
			}
		}
		return ii
	}
}

func getLastIndexOfString(str as string, s as string, start as int = -1) static as int
{
	description [[
		Gets the last index of a given substring "s" in string "str", starting from
		index "start".
	]]
	IFDEF "target_dotnet_cs" {
		if start < 0:
			return lang "cs" (str, s) as int {{{ str.LastIndexOf(s) }}}
		return lang "cs" (str, s, start) as int {{{ str.LastIndexOf(s, start) }}}
	}
	ELSE IFDEF "target_java" {
		if start < 0:
			return lang "java" (str, s) as int {{{ str.lastIndexOf(s) }}}
		return lang "java" (str, s, start) as int {{{ str.lastIndexOf(s, start) }}}
	}
	ELSE IFDEF "target_objc" {
		return lang "objc" (str, s, start) as int {{{ [str rangeOfString:s options:NSBackwardsSearch range:NSMakeRange(0, start < 0 ? [str length] : start)].location }}}
	}
	ELSE IFDEF "target_js" {
		if start <= 0:
			return lang "js" (str, s) as int {{{ str.lastIndexOf(s) }}}
		return lang "js" (str, s, start) as int {{{ str.lastIndexOf(s, start) }}}
	}
	ELSE IFDEF "target_kotlin" {
		if start <= 0:
			return lang "kotlin" (str, s) as int {{{ str.lastIndexOf(s) }}}
		return lang "kotlin" (str, s, start) as int {{{ str.lastIndexOf(s, start) }}}
	}
	ELSE {
		var ss = start
		if ss < 0:
			ss = 0
		var ii = getIndexOfString(str, s, ss)
		if ii >= 0 {
			loop {
				var ix = getIndexOfString(str, s, ii + 1)
				if ix < 0:
					break
				ii = ix
			}
		}
		return ii
	}
}

func getEndOfString(str as string, start as int) static as string
{
	description [[
		Gets a substring of "str", starting from index "start".
	]]
	var v as string?
	var ss = start
	if ss < 0:
		ss = 0
	if ss < getLength(str) {
		IFDEF "target_dotnet_cs" {
			v = lang "cs" (str, ss) as string {{{ str.Substring(ss) }}}
		}
		ELSE IFDEF "target_java" {
			v = lang "java" (str, ss) as string? {{{ str.substring(ss) }}}
		}
		ELSE IFDEF "target_objc" {
			v = lang "objc" (str, ss) as string? {{{ [str substringFromIndex:ss] }}}
		}
		ELSE IFDEF "target_js" {
			v = lang "js" (str, ss) as string? {{{ str.substring(ss) }}}
		}
		ELSE IFDEF "target_kotlin" {
			v = lang "kotlin" (str, ss) as string? {{{ str.substring(ss) }}}
		}
		ELSE IFDEF "target_sushi" {
			v = lang "lua" (str, ss) as string? {{{ _util:get_substring(str, ss, #str) }}}
		}
		ELSE IFDEF "target_swift" {
			lang "swift" (str, ss) {{{
				let startIdx = str.index(str.startIndex, offsetBy: ss)
				v = Swift.String(str[startIdx...])
			}}}
		}
		ELSE {
			nop str
			nop start
			ERROR NOT_IMPLEMENTED
		}
	}
	if not v:
		v = ""
	return v
}

func getSubString(str as string, start as int, length as int) static as string
{
	description [[
		Gets a substring of "str", starting from index "start" and with a maximum length
		of "length".
	]]
	var ss = start
	if ss < 0:
		ss = 0
	IFDEF "target_dotnet_cs" {
		return lang "cs" (str, ss, length) as string {{{ str.Substring(ss, length) }}}
	}
	ELSE IFDEF "target_objc" {
		var v = lang "objc" (str, ss, length) as string? {{{ [str substringWithRange:NSMakeRange(ss, length)] }}}
		if not v:
			v = ""
		return v
	}
	ELSE IFDEF "target_java" {
		var v = lang "java" (str, ss, length) as string? {{{ str.substring(ss, ss+length) }}}
		if not v:
			v = ""
		return v
	}
	ELSE IFDEF "target_js" {
		var ll = length
		var v = lang "js" (str, ss, ll) as string? {{{ str.substring(ss, ss+ll) }}}
		if not v:
			v = ""
		return v
	}
	ELSE IFDEF "target_kotlin" {
		var v = lang "kotlin" (str, ss, length) as string? {{{ str.substring(ss, ss+length) }}}
		if not v:
			v = ""
		return v
	}
	ELSE IFDEF "target_sushi" {
		var v = lang "lua" (str, ss, length) as string? {{{ _util:get_substring(str, ss, ss+length) }}}
		if not v:
			v = ""
		return v
	}
	ELSE IFDEF "target_swift" {
		var v as string?
		lang "swift" (str, ss, length) {{{
			let fromIndex = str.index(str.startIndex, offsetBy: ss)
			let toIndex = str.index(str.endIndex, offsetBy: (ss - str.count) + length)
			v = Swift.String(str[fromIndex..<toIndex])
		}}}
		if not v:
			v = ""
		return v
	}
	ELSE {
		nop str
		nop start
		nop length
		ERROR NOT_IMPLEMENTED
	}
}

func contains(str1 as string, str2 as string) static as bool
{
	description [[
		Checks is the string "str1" contains a substring "str2". Returns true if the
		substring is found.
	]]
	IFDEF "target_dotnet_cs" {
		return lang "cs" (str1, str2) as bool {{{ str1.Contains(str2) }}}
	}
	ELSE IFDEF "target_objc" {
		return lang "objc" (str1, str2) as bool {{{ [str1 containsString:str2] }}}
	}
	ELSE IFDEF "target_java" {
		return lang "java" (str1, str2) as bool {{{ str1.contains(str2) }}}
	}
	ELSE IFDEF "target_js" {
		var x as bool
		lang "js" (str1, str2) {{{
			if(!str1.includes) {
				x = str1.indexOf(str2) !== -1;
			}
			else {
				x = str1.includes(str2);
			}
		}}}
		return x
	}
	ELSE IFDEF "target_kotlin" {
		return lang "kotlin" (str1, str2) as bool {{{ str1.contains(str2) }}}
	}
	ELSE IFDEF "target_swift" {
		return lang "swift" (str1, str2) as bool {{{ str1.contains(str2) }}}
	}
	ELSE {
		if getIndexOfString(str1, str2) >= 0:
			return true
		return false
	}
}

func startsWith(str1 as string, str2 as string, offset as int = 0) static as bool
{
	description [[
		Checks if the string "str1" starts with the complete contents of "str2". If the
		"offset" parameter is supplied an is greater than zero, the checking does not
		start from the beginning of "str1" but from the given character index.
	]]
	var nstr as string?
	if offset > 0 {
		nstr = getEndOfString(str1, offset)
	}
	else {
		nstr = str1
	}
	IFDEF "target_dotnet_cs" {
		return lang "cs" (nstr, str2) as bool {{{ nstr.StartsWith(str2) }}}
	}
	ELSE IFDEF "target_objc" {
		return lang "objc" (nstr, str2) as bool {{{ [nstr hasPrefix:str2] }}}
	}
	ELSE IFDEF "target_java" {
		return lang "java" (nstr, str2) as bool {{{ nstr.startsWith(str2) }}}
	}
	ELSE IFDEF "target_js" {
		var x as bool
		lang "js" (nstr, str2) {{{
			if(!nstr.startsWith) {
				x = nstr.indexOf(str2) === 0;
			}
			else {
				x = nstr.startsWith(str2);
			}
		}}}
		return x
	}
	ELSE IFDEF "target_kotlin" {
		return lang "kotlin" (nstr, str2) as bool {{{ nstr.startsWith(str2) }}}
	}
	ELSE IFDEF "target_sushi" {
		return lang "lua" (str1, str2, offset) as bool {{{ _util:string_starts_with(str1, str2, offset) }}}
	}
	ELSE IFDEF "target_stdlua" {
		return lang "lua" (str1, str2) as bool {{{ string.sub(str1, 1, string.len(str2)) == str2 }}}
	}
	ELSE IFDEF "target_swift" {
		return lang "swift" (nstr, str2) as bool {{{ nstr!.hasPrefix(str2) }}}
	}
	ELSE {
		nop str1
		nop str2
		nop offset
		ERROR NOT_IMPLEMENTED
	}
}

func startsWithAny(str as string, strings as array<string>) static as string?
{
	description [[
		Checks if the string "str" starts with any of the strings "strings". The
		matching string will be returned by the method, or null if none of the strings
		matched.
	]]
	foreach str2 in strings {
		if startsWith(str, str2):
			return str2
	}
	return null
}

func startsWithIgnoreCase(str1 as string, str2 as string, offset as int = 0) static as bool
{
	description [[
		Checks if the string "str1" starts with the complete contents of "str2",
		ignoring any differences between uppercase and lowercase characters. If the
		"offset" parameter is supplied an is greater than zero, the checking does not
		start from the beginning of "str1" but from the given character index.
	]]
	return startsWith(toLowerCase(str1), toLowerCase(str2), offset)
}

func startsWithAnyIgnoreCase(str as string, strings as array<string>) static as string?
{
	description [[
		Checks if the string "str" starts with any of the strings "strings", ignoring
		any differences between uppercase and lowercase characters. The matching string
		will be returned by the method, or null if none of the strings matched.
	]]
	var ostr = toLowerCase(str)
	foreach str2 in strings {
		if startsWith(ostr, toLowerCase(str2)):
			return str2
	}
	return null
}

func endsWith(str1 as string, str2 as string) static as bool
{
	description [[
		Checks if the string "str1" ends with the complete contents of "str2".
	]]
	IFDEF "target_dotnet_cs" {
		return lang "cs" (str1, str2) as bool {{{ str1.EndsWith(str2) }}}
	}
	ELSE IFDEF "target_objc" {
		return lang "objc" (str1, str2) as bool {{{ [str1 hasSuffix:str2] }}}
	}
	ELSE IFDEF "target_java" {
		return lang "java" (str1, str2) as bool {{{ str1.endsWith(str2) }}}
	}
	ELSE IFDEF "target_js" {
		var x as bool
		lang "js" (str1, str2) {{{
			if(!str1.endsWith) {
				x = str1.indexOf(str2) === str1.length - str2.length;
			}
			else {
				x = str1.endsWith(str2);
			}
		}}}
		return x
	}
	ELSE IFDEF "target_kotlin" {
		return lang "kotlin" (str1, str2) as bool {{{ str1.endsWith(str2) }}}
	}
	ELSE IFDEF "target_sushi" {
		var s1 = lang "lua" (str1) as int {{{ _util:get_utf8_character_count(str1) }}}
		return lang "lua" (str1, s1, str2) as bool {{{ _util:get_substring(str1, s1 -_util:get_utf8_character_count(str2), s1) == str2 }}}
	}
	ELSE IFDEF "target_stdlua" {
		return lang "lua" (str1, str2) as bool {{{ string.sub(str1, string.len(str1)-string.len(str2), string.len(str1)) == str2 }}}
	}
	ELSE IFDEF "target_swift" {
		return lang "swift" (str1, str2) as bool {{{ str1.hasSuffix(str2) }}}
	}
	ELSE {
		nop str1
		nop str2
		ERROR NOT_IMPLEMENTED
	}
}

func endsWithAny(str as string, strings as array<string>) static as string?
{
	description [[
		Checks if the string "str" ends with any of the strings "strings". The matching
		string will be returned by the method, or null if none of the strings matched.
	]]
	foreach str2 in strings {
		if endsWith(str, str2):
			return str2
	}
	return null
}

func endsWithIgnoreCase(str1 as string, str2 as string) static as bool
{
	description [[
		Checks if the string "str1" ends with the complete contents of "str2", ignoring
		any differences between uppercase and lowercase characters.
	]]
	return endsWith(toLowerCase(str1), toLowerCase(str2))
}

func endsWithAnyIgnoreCase(str as string, strings as array<string>) static as string?
{
	description [[
		Checks if the string "str" ends with any of the strings "strings", ignoring any
		differences between uppercase and lowercase characters. The matching string will
		be returned by the method, or null if none of the strings matched.
	]]
	var ostr = toLowerCase(str)
	foreach str2 in strings {
		if endsWith(ostr, toLowerCase(str2)):
			return str2
	}
	return null
}

func strip(str as string) static as string
{
	description [[
		Strips (or trims) the given string "str" by removing all blank characters from
		both ends (the beginning and the end) of the string.
	]]
	IFDEF "target_dotnet_cs" {
		return safeString(lang "cs" (str) as string {{{ str.Trim() }}})
	}
	ELSE IFDEF "target_java" {
		return safeString(lang "java" (str) as string {{{ str.trim() }}})
	}
	ELSE IFDEF "target_js" {
		return safeString(lang "js" (str) as string? {{{ str.trim() }}})
	}
	ELSE IFDEF "target_objc" {
		return safeString(lang "objc" (str) as string {{{ [str stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]] }}})
	}
	ELSE IFDEF "target_kotlin" {
		return safeString(lang "kotlin" (str) as string? {{{ str.trim() }}})
	}
	ELSE IFDEF "target_swift" {
		return safeString(lang "swift" (str) as string {{{ str.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines) }}})
	}
	ELSE {
		return stripFromStart(stripFromEnd(str))
	}
}

func stripFromEnd(str as string) static as string
{
	description [[
		Strips (or trims) the given string "str" by removing all blank characters from
		the end of the string.
	]]
	IFDEF "target_dotnet_cs" {
		return lang "cs" (str) as string {{{ str.TrimEnd(null) }}}
	}
	ELSE {
		var ll = getLength(str)
		if ll < 1:
			return str
		var n = 0
		loop {
			var c = getChar(str, ll - 1 - n)
			if c == ' ' || c == '\t' || c == '\r' || c == '\n' {
				n++
			}
			else {
				break
			}
		}
		if n < 1:
			return str
		return getSubString(str, 0, ll - n)
	}
}

func stripFromStart(str as string) static as string
{
	description [[
		Strips (or trims) the given string "str" by removing all blank characters from
		the beginning of the string.
	]]
	IFDEF "target_dotnet_cs" {
		return lang "cs" (str) as string {{{ str.TrimStart(null) }}}
	}
	ELSE {
		var n = 0
		loop {
			var c = getChar(str, n)
			if c == ' ' || c == '\t' || c == '\r' || c == '\n' {
				n++
			}
			else {
				break
			}
		}
		if n < 1:
			return str
		return getEndOfString(str, n)
	}
}

func replaceCharacter(str as string, oldChar as char, newChar as char) static as string
{
	description [[
		Replaces all instances of "oldChar" with the value of "newChar" in the given
		string "str". The return value is a new string where the changes have been
		effected. The original string remains unchanged.
	]]
	IFDEF "target_dotnet_cs" {
		return lang "cs" (str, oldChar, newChar) as string {{{ str.Replace(oldChar, newChar) }}}
	}
	ELSE IFDEF "target_java" {
		return lang "java" (str, oldChar, newChar) as string {{{ str.replace(oldChar, newChar) }}}
	}
	ELSE IFDEF "target_node_js" {
		var result = ""
		lang "js" (str, oldChar, newChar) {{{
			const sa = Array.from(str);
			sa.forEach(cc => {
				if (cc.charCodeAt() == oldChar) {
					result += String.fromCharCode(newChar);
				}
				else {
					result += cc;
				}
			})
		}}}
		return result
	}
	ELSE IFDEF "target_js" {
		return lang "js" (str, oldChar, newChar) as string? {{{ str.replace(oldChar, newChar) }}} ?? ""
	}
	ELSE IFDEF "target_kotlin" {
		return lang "kotlin" (str, oldChar, newChar) as string {{{ str.replace(oldChar, newChar) }}}
	}
	ELSE {
		return replaceString(str, forCharacter(oldChar), forCharacter(newChar))
	}
}

func replaceString(str as string, target as string, replacement as string) static as string
{
	description [[
		Replaces all instances of the substring "target" with the value of "replacement"
		in the given string "str". The return value is a new string where the changes
		have been effected. The original string remains unchanged.
	]]
	if isEmpty(target):
		return str
	var rr = replacement
	IFDEF "target_dotnet_cs" {
		return safeString(lang "cs" (str, target, rr) as string {{{ str.Replace(target, rr) }}})
	}
	ELSE IFDEF "target_java" {
		return safeString(lang "java" (str, target, rr) as string? {{{ str.replace(target, rr) }}})
	}
	ELSE IFDEF "target_js" {
		return safeString(lang "js" (str, target, rr) as string? {{{ str.replaceAll(target, rr) }}})
	}
	ELSE IFDEF "target_objc" {
		return safeString(lang "objc" (str, target, rr) as string? {{{ [str stringByReplacingOccurrencesOfString: target withString: rr] }}})
	}
	ELSE IFDEF "target_kotlin" {
		return safeString(lang "kotlin" (str, target, rr) as string? {{{ str!!.replace(target!!, rr, false) }}})
	}
	ELSE IFDEF "target_swift" {
		return lang "swift" (str, target, rr) as string {{{ str.replacingOccurrences(of: target, with: rr) }}}
	}
	ELSE {
		var v = str
		loop {
			var p = getIndexOfString(v, target)
			if p < 0:
				break
			var sb = new StringBuilder()
			sb.appendString(getSubString(v, 0, p))
			sb.appendString(rr)
			sb.appendString(getEndOfString(v, p + getLength(target)))
			v = sb.toString()
		}
		return v
	}
}

func toCharArray(str as string) static as array<char>
{
	description [[
		Converts the string "str" to an array of characters.
	]]
	IFDEF "target_dotnet_cs" {
		return lang "cs" (str) as array<char> {{{ str.ToCharArray() }}}
	}
	ELSE IFDEF "target_java" {
		return lang "java" (str) as array<char> {{{ str.toCharArray() }}}
	}
	ELSE IFDEF "target_js" {
		var v as array<char>?
		lang "js" (str) {{{
			v = [];
			for (var i = 0; i < str.length; i++) {
				v[i] = str.charAt(i).charCodeAt();
			}
		}}}
		return v as! array<char>
	}
	ELSE IFDEF "target_objc" {
		var ca as array<char>?
		lang "objc" (str) {{{
			ca = [[NSMutableArray alloc] init];
			for(int i = 0; i < [str length]; i++) {
				CFStringRef strcf = (__bridge CFStringRef)str;
				CFRange r = CFStringGetRangeOfComposedCharactersAtIndex(strcf, i);
				if(r.length > 1) {
					UniChar v[r.length];
					CFStringGetCharacters(strcf, r, v);
					for(int x = 0; x < r.length; x++) {
						if((x + 1) < r.length && CFStringIsSurrogateHighCharacter(v[x]) && CFStringIsSurrogateLowCharacter(v[x + 1])) {
							UTF32Char c = CFStringGetLongCharacterForSurrogatePair(v[x], v[x + 1]);
							[ca addObject:[NSNumber numberWithUnsignedInt:c]];
							x++;
							continue;
						}
						[ca addObject:[NSNumber numberWithUnsignedInt:v[x]]];
					}
					i += (r.length - 1);
					continue;
				}
				UniChar v[1];
				CFStringGetCharacters(strcf, r, v);
				[ca addObject:[NSNumber numberWithUnsignedInt:v[0]]];
			}
		}}}
		return ca as! array<char>
	}
	ELSE IFDEF "target_kotlin" {
		return lang "kotlin" (str) as array<char> {{{ str.toCharArray() }}}
	}
	ELSE IFDEF "target_swift" {
		var v = new char[getLength(str)]
		lang "swift" (str) {{{
			var n = 0
			for cc in str.unicodeScalars {
				v.setValue(n, Swift.UInt32(cc.value))
				n += 1
			}
		}}}
		return v
	}
	ELSE IFDEF "target_lua" {
		var v as array<char>?
		var it = iterate(str)
		lang "lua" {{{
			v = {}
		}}}
		var n = 0
		while it {
			var c = it.getNextChar()
			if Character.isEOF(c):
				break
			lang "lua" (v, n, c) {{{
				v[n + 1] = c
			}}}
			n++
		}
		return v as! array<char>
	}
	ELSE {
		nop str
		ERROR NOT_IMPLEMENTED
	}
}

func split(str as string, delim as char, max as int = 0) static as vector<string>
{
	description [[
		Splits the string "str" to a vector of strings, cutting the original string at
		each instance of the character "delim". If the value of "max" is supplied and is
		given a value greater than 0, then the resulting vector will only have a maximum
		of "max" entries. If the delimiter character appears beyond the maximum entries,
		the last entry in the vector will be the complete remainder of the original
		string, including the remaining delimiter characters.
	]]
	var v = new vector<string>
	IFDEF "target_sushi" {
		var it = iterate(str)
		var sb = new StringBuilder()
		var n = 0
		loop {
			var c = it.getNextChar()
			if Character.isEOF(c):
				break
			if c == delim && (max < 1 || n < max - 1) {
				v += sb.toString()
				sb.clear()
				n++
			}
			else {
				sb.appendCharacter(c)
			}
		}
		v += sb.toString()
	}
	ELSE {
		var n = 0
		loop {
			if max > 0 && Vector.getSize(v) >= max - 1 {
				v += getEndOfString(str, n)
				break
			}
			var x = getIndexOfCharacter(str, delim, n)
			if x < 0 {
				v += getEndOfString(str, n)
				break
			}
			v += getSubString(str, n, x - n)
			n = x + 1
		}
	}
	return v
}

func isInteger(str as string) static as bool
{
	description [[
		Checks if the given string is fully an integer (no other characters appear in
		the string).
	]]
	foreach c in iterate(str) {
		if c < '0' || c > '9':
			return false
	}
	return true
}

func iterate(value as string) static as Iterator<char>
{
	description [[
		Iterates the string "string" character by character by using an instance of
		Iterator<char>.
	]]
	return CharacterIteratorForString.forString(value)
}

func iterateAsCharacterIterator(value as string) static as CharacterIterator
{
	description [[
		Iterates the string "string" character by character by using an instance of
		CharacterIterator.
	]]
	return CharacterIteratorForString.forString(value)
}

func reverse(value as string) static as string
{
	description [[
		Creates a new string that contains the same contents as "string", but with all
		characters appearing in reverse order.
	]]
	var sb = new StringBuilder()
	foreach c in iterate(value):
		sb.insertCharacter(0, c)
	return sb.toString()
}

func iterateReverse(value as string) static as Iterator<char>
{
	description [[
		Iterates the string "string" in reverse order (starting from the end, moving
		towards the beginning).
	]]
	return iterate(reverse(value))
}
