
/*
 * This file is part of Eqela Jkop
 * Copyright (c) 2016-2023 J42 Pte Ltd
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import jk.fs
import jk.io
import jk.lang
import jk.nodejs

class is AzureStorageDataClient:

depend "npm@azure/storage-blob:12.14.0"

class BlobListIteratorImpl is BlobListIterator
{
	var iterator as dynamic

	ctor(iterator as dynamic):
		this.iterator = iterator

	func next async as BlobProperties
	{
		var data = await iterator.next()
		if data.done == true:
			return null
		var blobProperties = new BlobProperties()
		blobProperties.name = String.asString(data.value.name)
		blobProperties.snapshot = String.asString(data.value.snapshot)
		blobProperties.versionId = String.asString(data.value.versionId)
		blobProperties.isCurrentVersion = Boolean.asBoolean(data.value.isCurrentVersion)
		blobProperties.createdOn = String.asString(data.value.properties.createdOn)
		blobProperties.lastModified = String.asString(data.value.properties.lastModified)
		blobProperties.contentLength = Integer.asInteger(data.value.properties.contentLength)
		blobProperties.contentType = String.asString(data.value.properties.contentType)
		blobProperties.contentEncoding = String.asString(data.value.properties.contentEncoding)
		blobProperties.blobType = String.asString(data.value.properties.blobType)
		blobProperties.accessTier = String.asString(data.value.properties.accessTier)
		return blobProperties
	}
}

class ReadableStreamImpl is ReadableStream public
{
	var stream as !"RetriableReadableStream"

	ctor(stream as dynamic):
		this.stream = stream

	func readAsString async as string
	{
		var readableStream = stream
		return lang "js" promise<string> {{{
			new Promise((resolve, reject) => {
				const chunk = [];
				readableStream.on("data", (data) => {
					chunk.push(data instanceof Buffer ? data : Buffer.from(data));
				});
				readableStream.on("end", () => {
					const str = Buffer.concat(chunk).toString();
					resolve(str);
				});
				readableStream.on("error", (error) => {
					reject(error);
				});
			});
		}}}
	}

	func readAsBuffer async as buffer
	{
		var readableStream = stream
		return lang "js" promise<buffer> {{{
			new Promise((resolve, reject) => {
				const chunk = [];
				readableStream.on("data", (data) => {
					chunk.push(Buffer.from(data));
				});
				readableStream.on("end", () => {
					resolve(Buffer.concat(chunk));
				});
				readableStream.on("error", (error) => {
					reject(error)
				});
			});
		}}}
	}
}

prop account as string
prop accountKey as string

ctor(account as string, accountKey as string)
{
	this.account = account
	this.accountKey = accountKey
}

func getStorageBlobApi private static as dynamic:
	return NodeModule.require("@azure/storage-blob")

func getBlobServiceClient private as dynamic
{
	var api = getStorageBlobApi()
	var accountName = account
	var storageSharedKey = accountKey
	var endpoint = "https://"..account..".blob.core.windows.net"
	var storageSharedKeyCredential = lang "js" dynamic {{{ new api.StorageSharedKeyCredential(accountName, storageSharedKey) }}}
	return lang "js" dynamic {{{ new api.BlobServiceClient(endpoint, storageSharedKeyCredential) }}}
}

func getBlobContainerClient(containerName as string) private as dynamic
{
	var blobServiceClient = getBlobServiceClient()
	if not blobServiceClient:
		Error.throw("blobServiceClientError", blobServiceClient)
	var blobContainerClient = blobServiceClient.getContainerClient(containerName)
	if not blobContainerClient:
		Error.throw("blobContainerError", blobContainerClient)
	return blobContainerClient
}

func createBlobContainerIfNotExists(properties as CreateBlobContainerModel) override async
{
	var blobContainerClient = getBlobContainerClient(properties.containerName)
	var params = {}
	params.access = properties.containerAccess
	if not properties.containerAccess:
		params.access = "Container"
	var metadata = {}
	if properties.containerMetadata {
		foreach key in properties.containerMetadata.getKeys() {
			metadata[key] = properties.containerMetadata.getString(key)
		}
		params.metadata = metadata
	}
	await blobContainerClient.createIfNotExists(params)
}

func getBlobContainerProperties(containerName as string) override async as BlobContainerProperties
{
	var blobContainerClient = getBlobContainerClient(containerName)
	if await blobContainerClient.exists() == false:
		return null
	var properties = await blobContainerClient.getProperties()
	var blobProperties = new BlobContainerProperties()
	var metadata = properties.metadata
	blobProperties.metadata = lang "js" DynamicMap {{{ new Map(Object.entries(metadata)) }}}
	blobProperties.etag = String.asString(properties.etag)
	blobProperties.lastModified = String.asString(properties.lastModified)
	blobProperties.leaseDuration = String.asString(properties.leaseDuration)
	blobProperties.leaseState = String.asString(properties.leaseState)
	blobProperties.leaseStatus = String.asString(properties.leaseStatus)
	blobProperties.clientRequestId = String.asString(properties.clientRequestId)
	blobProperties.requestId = String.asString(properties.requestId)
	blobProperties.version = String.asString(properties.version)
	blobProperties.date = String.asString(properties.date)
	blobProperties.blobPublicAccess = String.asString(properties.blobPublicAccess)
	blobProperties.hasImmutabilityPolicy = properties.hasImmutabilityPolicy as bool
	blobProperties.hasLegalHold = properties.hasLegalHold as bool
	blobProperties.defaultEncryptionScope = String.asString(properties.defaultEncryptionScope)
	blobProperties.denyEncryptionScopeOverride = properties.denyEncryptionScopeOverride as bool
	blobProperties.isImmutableStorageWithVersioningEnabled = properties.isImmutableStorageWithVersioningEnabled as bool
	return blobProperties
}

func getContainerBlobsList(containerName as string, includeSnapshots as bool, includeVersions as bool) override async as BlobListIterator
{
	var blobContainerClient = getBlobContainerClient(containerName)
	if await blobContainerClient.exists() == false:
		Error.throw("blobContainerDoesNotExists", containerName)
	var iterator = await blobContainerClient.listBlobsFlat({ includeSnapshots includeSnapshots includeVersions includeVersions })
	if not iterator:
		return null
	return new BlobListIteratorImpl(iterator)
}

func updateBlobContainerAccessPolicy(properties as UpdateBlobContainerModel) override async
{
	var blobContainerClient = getBlobContainerClient(properties.containerName)
	if await blobContainerClient.exists() == false:
		Error.throw("blobContainerDoesNotExists", properties.containerName)
	var expiry = properties.accessPolicy.expiryAsDays
	var signedIdentifiersParams = {
		id properties.accessPolicy.policyId
		accessPolicy {
			startsOn lang "js" dynamic {{{ new Date() }}}
			expiresOn lang "js" dynamic {{{ new Date(new Date().getTime() + expiry * 24 * 60 * 60 * 1000) }}}
			permissions ""
		}
	}
	if properties.accessPolicy.read:
		signedIdentifiersParams.accessPolicy.permissions += "r"
	if properties.accessPolicy.add:
		signedIdentifiersParams.accessPolicy.permissions += "a"
	if properties.accessPolicy.create:
		signedIdentifiersParams.accessPolicy.permissions += "c"
	if properties.accessPolicy.write:
		signedIdentifiersParams.accessPolicy.permissions += "w"
	if properties.accessPolicy.delete:
		signedIdentifiersParams.accessPolicy.permissions += "d"
	if properties.accessPolicy.list:
		signedIdentifiersParams.accessPolicy.permissions += "l"
	var signedIdentifiers = [ signedIdentifiersParams ]
	await await blobContainerClient.setAccessPolicy(properties.access, signedIdentifiers)
}

func deleteBlobContainer(containerName as string) override async
{
	var blobContainerClient = getBlobContainerClient(containerName)
	if await blobContainerClient.exists() == false:
		Error.throw("blobContainerDoesNotExists", containerName)
	await blobContainerClient.delete()
}

func upload(containerName as string, blobName as string, blobData as buffer, forceUpdate as bool) override async
{
	var blobContainerClient = getBlobContainerClient(containerName)
	if await blobContainerClient.exists() == false:
		Error.throw("blobContainerDoesNotExists", containerName)
	var blockClient = blobContainerClient.getBlockBlobClient(blobName)
	if await blockClient.exists() == true && not forceUpdate:
		Error.throw("blobAlreadyExists", blobName)
	await blockClient.upload(blobData, Buffer.getSize(blobData))
}

func uploadFile(containerName as string, blobData as File, forceUpdate as bool = false) override async
{
	var blobContainerClient = getBlobContainerClient(containerName)
	if await blobContainerClient.exists() == false:
		Error.throw("blobContainerDoesNotExists", containerName)
	var blobName = blobData.getBasename()
	var blockClient = blobContainerClient.getBlockBlobClient(blobName)
	if await blockClient.exists() == true && not forceUpdate:
		Error.throw("blobAlreadyExists", blobName)
	await blockClient.uploadFile(blobData.getPath())
}

func uploadStream(containerName as string, blobData as File, forceUpdate as bool = false) override async
{
	var blobContainerClient = getBlobContainerClient(containerName)
	if await blobContainerClient.exists() == false:
		Error.throw("blobContainerDoesNotExists", containerName)
	var blobName = blobData.getBasename()
	var fs = lang "js" dynamic {{{ require('fs') }}}
	var blockClient = blobContainerClient.getBlockBlobClient(blobName)
	if await blockClient.exists() == true && not forceUpdate:
		Error.throw("blobAlreadyExists", blobName)
	var stream = fs.createReadStream(blobData.getPath())
	var bufferSize = 4 * 1024 * 1024
	var maxConcurrency = 20
	await blockClient.uploadStream(stream, bufferSize, maxConcurrency)
}

func uploadPageBlob(containerName as string, blobData as File, offset as int, pageSize as int, forceUpdate as bool) override async
{
	var blobContainerClient = getBlobContainerClient(containerName)
	if await blobContainerClient.exists() == false:
		Error.throw("blobContainerDoesNotExists", containerName)
	var blobName = blobData.getBasename()
	var pageClient = blobContainerClient.getPageBlobClient(blobName)
	if await pageClient.exists() == true && not forceUpdate:
		Error.throw("blobAlreadyExists", blobName)
	if pageSize % 512 != 0:
		Error.throw("pageSizeMustBeMultipleOf512", pageSize)
	var bufferSize = Buffer.getSize(blobData.getContentsBuffer())
	if bufferSize % 512 != 0:
		Error.throw("blobSizeMustBeMultipleOf512", bufferSize)
	await pageClient.createIfNotExists(pageSize)
	await pageClient.uploadPages(blobData.getContentsBuffer(), offset, bufferSize)
}

func uploadAppendBlob(containerName as string, blobData as File, forceUpdate as bool) override async
{
	var blobContainerClient = getBlobContainerClient(containerName)
	if await blobContainerClient.exists() == false:
		Error.throw("blobContainerDoesNotExists", containerName)
	var blobName = blobData.getBasename()
	var appendClient = blobContainerClient.getAppendBlobClient(blobName)
	if await appendClient.exists() == true && not forceUpdate:
		Error.throw("blobAlreadyExists", blobName)
	await appendClient.createIfNotExists()
	await appendClient.appendBlock(blobData.getContentsBuffer(), Buffer.getSize(blobData.getContentsBuffer()))
}

func getBlobProperties(containerName as string, blobName as string) override async as BlobProperties
{
	var blobContainerClient = getBlobContainerClient(containerName)
	if await blobContainerClient.exists() == false:
		Error.throw("blobContainerDoesNotExists", containerName)
	var blobClient = blobContainerClient.getBlobClient(blobName)
	if await blobClient.exists() == false:
		Error.throw("blobDoesNotExists", blobName)
	var data = await blobClient.getProperties()
	var blobProperties = new BlobProperties()
	blobProperties.name = blobName
	blobProperties.versionId = String.asString(data.versionId)
	blobProperties.isCurrentVersion = Boolean.asBoolean(data.isCurrentVersion)
	blobProperties.createdOn = String.asString(data.createdOn)
	blobProperties.lastModified = String.asString(data.lastModified)
	blobProperties.contentLength = Integer.asInteger(data.contentLength)
	blobProperties.contentType = String.asString(data.contentType)
	blobProperties.contentEncoding = String.asString(data.contentEncoding)
	blobProperties.blobType = String.asString(data.blobType)
	blobProperties.accessTier = String.asString(data.accessTier)
	return blobProperties
}

func downloadAsReadableStream(containerName as string, blobName as string) override async as ReadableStream
{
	var blobContainerClient = getBlobContainerClient(containerName)
	if await blobContainerClient.exists() == false:
		Error.throw("blobContainerDoesNotExists", containerName)
	var blobClient = blobContainerClient.getBlobClient(blobName)
	if await blobClient.exists() == false:
		Error.throw("blobDoesNotExists", blobName)
	var v = await blobClient.download()
	return new ReadableStreamImpl(v.readableStreamBody)
}

func downloadAsBuffer(containerName as string, blobName as string) override async as buffer
{
	var blobContainerClient = getBlobContainerClient(containerName)
	if await blobContainerClient.exists() == false:
		Error.throw("blobContainerDoesNotExists", containerName)
	var blobClient = blobContainerClient.getBlobClient(blobName)
	if await blobClient.exists() == false:
		Error.throw("blobDoesNotExists", blobName)
	return Buffer.asBuffer(await blobClient.downloadToBuffer())
}

func downloadAsFile(containerName as string, blobName as string, directory as File) override async
{
	var blobContainerClient = getBlobContainerClient(containerName)
	if await blobContainerClient.exists() == false:
		Error.throw("blobContainerDoesNotExists", containerName)
	var blobClient = blobContainerClient.getBlobClient(blobName)
	if await blobClient.exists() == false:
		Error.throw("blobDoesNotExists", blobName)
	await blobClient.downloadToFile(directory.entry(blobName).getPath())
}

func deleteBlob(containerName as string, blobName as string) override async
{
	var blobContainerClient = getBlobContainerClient(containerName)
	if await blobContainerClient.exists() == false:
		Error.throw("blobContainerDoesNotExists", containerName)
	var blobClient = blobContainerClient.getBlobClient(blobName)
	if await blobClient.exists() == false:
		Error.throw("blobDoesNotExists", blobName)
	await blobClient.delete({ deleteSnapshots "include" })
}
