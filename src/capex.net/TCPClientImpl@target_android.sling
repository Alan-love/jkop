
/*
 * This file is part of Jkop
 * Copyright (c) 2016-2018 Job and Esther Technologies Oy
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

class is TCPClient imports cape:

depend "androidPermission:android.permission.INTERNET"

class Task implements !"java.lang.Runnable"
{
	ctor(h as function):
		handler = h

	var handler as function

	func run
	{
		if handler:
			handler()
	}
}

class TCPClientThread private extends !"android.os.HandlerThread"
{
	ctor(name as string, hdrl as !"android.os.Handler")
	{
		base(name)
		uiHandler = hdrl
	}

	var uiHandler as !"android.os.Handler"
	var myHandler as !"android.os.Handler"
	var readThreadIsRunning volatile as bool
	var readThreadStopFlag volatile as bool
	var receiveCallback as function<void, buffer, int>
	var errorCallback as function
	var taskQueue as Queue<Task>
	var socket as TCPSocket

	func onLooperPrepared
	{
		myHandler = new !"android.os.Handler"(lang "java" !"android.os.Looper" {{{ getLooper() }}})
		if taskQueue {
			loop {
				var t = taskQueue.pop()
				if not t:
					break
				doExecuteInTCPThread(t)
			}
		}
	}

	func startThread
	{
		base.start()
		socket = TCPSocket.create()
	}

	func stopThread
	{
		base.quit()
		socket = null
		if readThreadIsRunning:
			readThreadStopFlag = true
	}

	func setErrorCallback(ec as function):
		errorCallback = ec

	func isRunning as bool:
		return lang "java" bool {{{ isAlive() }}}

	func executeErrorCallback(callback as function<void, Error>, error as Error = null)
	{
		assert callback
		var c final = callback
		var e final = error
		executeInUIThread(func {
			if e && errorCallback:
				errorCallback()
			c(e)
		})
	}

	func executeResponseCallback(buffer as buffer, size as int)
	{
		assert receiveCallback
		var c final = receiveCallback
		var b final = buffer
		var s final = size
		executeInUIThread(func {
			c(b, s)
		})
	}

	func executeInUIThread(f as function):
		uiHandler.post(new Task(f))

	func executeInTCPThread(f as function)
	{
		assert f
		if not myHandler {
			if not taskQueue:
				taskQueue = new Queue<Task>()
			taskQueue.push(new Task(f))
			return
		}
		doExecuteInTCPThread(new Task(f))
	}

	func doExecuteInTCPThread(task as Task):
		myHandler.post(task)

	func runReadThread private
	{
		assert readThreadIsRunning == false
		var ts = new Task(func {
			var receiveBuffer final = MALLOC(64 * 1024)
			while readThreadStopFlag == false {
				var r final = socket.read(receiveBuffer)
				if r < 0 {
					break
				}
				else if r == 0 {
					continue
				}
				executeInTCPThread(func {
					executeResponseCallback(receiveBuffer, r)
				})
			}
			readThreadIsRunning = false
			readThreadStopFlag = false
		})
		var readThread = new !"java.lang.Thread"(ts)
		readThread.start()
		readThreadIsRunning = true
	}

	func connect(address as string, port as int, callback as function<void, Error>)
	{
		var a final = address
		var p final = port
		var c final = callback
		executeInTCPThread(func {
			if socket.connect(a, p) == false {
				if c:
					executeErrorCallback(c, Error.forMessage("Failed to establish a connection to socket"))
				return
			}
			if c:
				executeErrorCallback(c)
			runReadThread()
		})
	}

	func disconnect(callback as function<void, Error>)
	{
		var c final = callback
		executeInTCPThread(func {
			socket.close()
			executeErrorCallback(c)
		})
	}

	func receive(callback as function<void, buffer, int>):
		receiveCallback = callback

	func send(data as buffer, size as int, callback as function<void, Error>)
	{
		var d final = data
		var s final = size
		var c final = callback
		executeInTCPThread(func {
			if socket.write(d, s) < 1 {
				socket.close()
				if c:
					executeErrorCallback(c, Error.forMessage("Failed to send"))
				return
			}
			if c:
				executeErrorCallback(c)
		})
	}
}

var thread as TCPClientThread
var counter static = 0

func initializeThread private
{
	if thread:
		destroyThread()
	thread = new TCPClientThread("JkopTCPClientThread" .. String.asString(counter++), new !"android.os.Handler"())
	thread.setErrorCallback(destroyThread)
	thread.startThread()
}

func destroyThread private
{
	if thread.isRunning():
		thread.stopThread()
	thread = null
}

func connect(address as string, port as int, callback as function<void,Error>) override
{
	initializeThread()
	thread.connect(address, port, callback)
}

func receive(callback as function<void,buffer,int>) override
{
	assert thread
	thread.receive(callback)
}

func send(data as buffer, size as int, callback as function<void,Error>) override
{
	assert thread
	thread.send(data, size, callback)
}

func disconnect(callback as function<void,Error>) override
{
	assert thread
	thread.disconnect(callback)
}
