
/*
 * This file is part of Jkop
 * Copyright (c) 2016-2017 Job and Esther Technologies, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

class #widget:

class MyContainerWidget is CustomContainerWidget private #widget
{
	class MyChild
	{
		var widget as Widget
		var x as int
	}

	ctor(ctx as GuiApplicationContext)
	{
		base(ctx)
	}

	var animating as bool
	var children as vector<MyChild>
	var currentIndex as int
	var widgetWidth as int
	prop widgetAnimationDuration as long = 1000
	prop widgetAnimationProgressListener as function<void, double>
	prop widgetCurrentWidgetChangeListener as function<void, int, Widget>

	func onWidgetHeightChanged(height as int #notLiteral) override
	{
		base.onWidgetHeightChanged(height)
		foreach child in Widget.getChildren(this) {
			Widget.resizeHeight(child, height)
		}
	}

	func computeWidgetLayout(widthConstraint as int #notLiteral) override
	{
		var widgets = Widget.getChildren(this)
		var childCount = SIZE widgets
		var wc = widthConstraint
		var mw as int
		var mh as int
		foreach child in widgets {
			Widget.layout(child, wc)
			var tw = Widget.getWidth(child)
			if tw > mw:
				mw = tw
			var th = Widget.getHeight(child)
			if th > mh:
				mh = th
		}
		children = new vector<MyChild>
		for(var i = 0; i < childCount; i++) {
			var mc = new MyChild()
			mc.widget = widgets[i]
			mc.x = i*mw
			children += mc
			Widget.move(mc.widget, mc.x, 0)
		}
		widgetWidth = mw
		Widget.setLayoutSize(this, mw, 0)
		updateChildren()
	}

	func moveToNext as bool
	{
		var nextAnimation = WidgetAnimation.forDuration(context, widgetAnimationDuration)
		if animating:
			return false
		if currentIndex == SIZE(children) - 1:
			return false
		nextAnimation.addCallback(func(completion as double) {
			widgetAnimationProgressListener(completion)
			for(var i = 0; i < SIZE(children); i++) {
				var child = children[i]
				var dx = child.x - (widgetWidth * completion) as int
				var dsx = (child.x - widgetWidth)
				if dx < dsx:
					dx = dsx
				Widget.move(child.widget, dx, 0)
			}
		})
		nextAnimation.setEndListener(func {
			updateChildren()
		})
		nextAnimation.start()
		animating = true
		return true
	}

	func moveToPrevious as bool
	{
		var prevAnimation = WidgetAnimation.forDuration(context, widgetAnimationDuration)
		if animating:
			return false
		if currentIndex == 0:
			return false
		prevAnimation.addCallback(func(completion as double) {
			widgetAnimationProgressListener(completion)
			for(var i = 0; i < SIZE(children); i++) {
				var child = children[i]
				var dx = child.x + (widgetWidth * completion) as int
				var dsx = (child.x + widgetWidth)
				if dx > dsx:
					dx = dsx
				Widget.move(child.widget, dx, 0)
			}
		})
		prevAnimation.setEndListener(func {
			updateChildren()
		})
		prevAnimation.start()
		animating = true
		return true
	}

	func moveToFirst
	{
		var firstAnimation = WidgetAnimation.forDuration(context, widgetAnimationDuration)
		if animating:
			return
		firstAnimation.addCallback(func(completion as double) {
			widgetAnimationProgressListener(completion)
			for(var i = 0; i < SIZE(children); i++) {
				var child = children[i]
				var dx = child.x + ((widgetWidth * currentIndex) * completion) as int
				var dsx = (child.x + (widgetWidth * currentIndex))
				if dx > dsx:
					dx = dsx
				Widget.move(child.widget, dx, 0)
			}
		})
		firstAnimation.setEndListener(func {
			updateChildren()
		})
		firstAnimation.start()
		animating = true
	}

	func updateChildren private
	{
		for(var i = 0; i < SIZE(children); i++) {
			var child = children[i]
			child.x = Widget.getX(child.widget)
			if child.x == 0 {
				currentIndex = i
				widgetCurrentWidgetChangeListener(currentIndex, child.widget)
			}
		}
		animating = false
	}
}

ui LayerWidget
{
	CanvasWidget background {
		color = Color.black()
	}
	MyContainerWidget carousell {
		animationProgressListener = func(completion as double) {
			if widgetAnimationProgressListener:
				widgetAnimationProgressListener(completion)
		}
		currentWidgetChangeListener = func(index as int, widget as Widget) {
			if widgetCurrentWidgetChangeListener:
				widgetCurrentWidgetChangeListener(index, widget)
		}
	}
	AlignWidget {
		LayerWidget prevSlot : 0.0, 0.5 {
		}
		LayerWidget nextSlot : 1.0, 0.5 {
		}
	}
}

prop widgetNextButton as Widget
prop widgetPreviousButton as Widget
prop widgetAnimationProgressListener as function<void, double>
prop widgetCurrentWidgetChangeListener as function<void, int, Widget>
prop widgetAutoSwitch as bool
prop widgetAutoSwitchInterval = 1.0
var timerRunning as bool

func initializeWidget override
{
	base.initializeWidget()
	if not widgetPreviousButton:
		widgetPreviousButton = TextButtonWidget.forText(context, "PREVIOUS")
	if not widgetNextButton:
		widgetNextButton = TextButtonWidget.forText(context, "NEXT")
	Widget.setWidgetClickHandler(widgetPreviousButton, func {
		carousell.moveToPrevious()
	})
	Widget.setWidgetClickHandler(widgetNextButton, func {
		carousell.moveToNext()
	})
	prevSlot.addWidget(widgetPreviousButton)
	nextSlot.addWidget(widgetNextButton)
	if widgetAutoSwitch {
		start()
	}
}

func start private
{
	if widgetAutoSwitchInterval < 1:
		return
	timerRunning = true
	onTick(SystemClock.asSeconds(), widgetAutoSwitchInterval * 1000 as long)
}

func stop private
{
	timerRunning = false
}

func onTick(lastTick as long, timeoutSeconds as long) private
{
	var diff = SystemClock.asSeconds() - lastTick
	var nextTick = timeoutSeconds
	if(diff > 0) {
		nextTick -= diff
	}
	var tos final = timeoutSeconds
	context.startTimer(nextTick, func {
		onPeriodicTimer()
		if(timerRunning) {
			onTick(SystemClock.asSeconds(), tos)
		}
	})
}

func onPeriodicTimer
{
	if not widgetAutoSwitch:
		stop()
	if not carousell.moveToNext():
		carousell.moveToFirst()
}

func setWidgetBackgroundColor(color as Color)
{
	background.setWidgetColor(color)
}

func setWidgetAnimationDuration(duration as long)
{
	carousell.setWidgetAnimationDuration(duration)
}

func setWidgetEntry(widget as Widget)
{
	carousell.addWidget(widget)
}
