
/*
 * This file is part of Jkop
 * Copyright (c) 2016-2018 Job and Esther Technologies Oy
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

class abstract:

import cape
import capex.data
import capex.net
import capex.crypto

prop server as WSServer
prop port = 9090
var ctx protected as LoggingContext
var connectionSize private as int
var random private as Random

func authenticateConnection(data as buffer) abstract as string
func getUser(userId as string) abstract as ChatUser
func getUserCount abstract as int
func createChannel(message as ChatMessage) abstract as ChatChannel
func getChannel(channelId as string) abstract as ChatChannel
func createAcknowledgeCommand(userId as string) abstract as ChatMessage
func createMessage(data as buffer) abstract as ChatMessage
func checkRecipients(recipients as DynamicVector) abstract as bool
func onUserOnline(user as ChatUser) abstract
func onUserOffline(user as ChatUser) abstract
func onNewCommandMessage(message as ChatMessage, connection as ChatConnectionHandler) abstract
func notifyUserForNewDataMessage(user as ChatUser, message as ChatMessage) abstract

ctor
{
	connectionSize = 0
	random = new Random()
}

func initialize virtual as bool:
	return true

func setCtx(ctx as LoggingContext):
	this.ctx = ctx

func getCtx as LoggingContext:
	return ctx

func initializeEngine(mgr as IOManager) as bool
{
	assert mgr:
		logError("No IOManager instance specified.")
	if not server {
		logWarning("No WebSocket server instance specified. Creating a new instance to listen on port: " .. String.forInteger(port) .. ".")
		server = new WSServer()
	}
	server.setPort(port)
	var engine final = this
	server.setCreateConnectionHandlerObject(func as WSServerConnectionHandler {
		return new ChatConnectionHandler().setEngine(engine).setLogContext(ctx)
	})
	assert server.initialize(mgr, ctx):
		logError("Failed to initialize WebSocket server.")
	assert initialize():
		logError("Failed to initialize chat engine.")
	logInfo("Successfully initialized chat engine.")
	return true
}

func generateId virtual as string:
	return MD5Encoder.encode(String.forInteger(SystemClock.asUTCSeconds()) .. String.forInteger(random.nextInt(9999999)) .. String.forInteger(random.nextInt(9999999)) .. String.forInteger(random.nextInt(9999999)))

func logError(message as string)
{
	assert ctx
	ctx.logError("ChatEngine: " .. message)
}

func logWarning(message as string)
{
	assert ctx
	ctx.logWarning("ChatEngine: " .. message)
}

func logInfo(message as string)
{
	assert ctx
	ctx.logInfo("ChatEngine: " .. message)
}

func logDebug(message as string)
{
	assert ctx
	ctx.logDebug("ChatEngine: " .. message)
}

func onDataReceived(data as buffer, connection as ChatConnectionHandler)
{
	assert connection
	assert data {
		connection.close()
	}
	var user = connection.getUser()
	if not user {
		onAuthenticateConnection(data, connection)
		return
	}
	onParseData(data, connection)
}

func onAuthenticateConnection(data as buffer, connection as ChatConnectionHandler) private
{
	var userId = authenticateConnection(data)
	assert String.isNotEmpty(userId) {
		logError("No userId returned by authenticateConnection() abstract method. Closing the connection instead.")
		connection.close()
	}
	var user = assert getUser(userId) {
		logError("No ChatUser instance returned by getUser() abstract method. Closing the connection instead.")
		connection.close()
	}
	connection.setUser(user)
	loop {
		var connectionId = generateId()
		assert String.isNotEmpty(connectionId) {
			logError("No connectionId returned by generateId() abstract method. Closing the connection instead.")
			connection.close()
		}
		if user.getConnection(connectionId) == null {
			connection.setConnectionId(connectionId)
			break
		}
	}
	user.addConnection(connection)
	connectionSize++
	logDebug("New connection. Now: (" .. String.forInteger(connectionSize) .. "/" .. String.forInteger(getUserCount()) .. ") connected")
	var message = assert createAcknowledgeCommand(userId) {
		logError("Failed to create an acknowledge command message that the client is connected. Closing the connection instead.")
		connection.close()
	}
	assert message.getMessageType() == ChatMessage.COMMAND_TYPE {
		logError("Acknowledge command message not of type command. Closing the connection instead.")
		connection.close()
	}
	var r = connection.sendMessage(message)
	assert r > 0 {
		logError("Failed to send message. Closing the connection instead.")
		connection.close()
	}
	if user.getConnectionCount() == 1 {
		logDebug("User: '" .. user.getUserId() .. "' is now online")
		onUserOnline(user)
	}
}

func onUserDisconnect(userId as string, connection as ChatConnectionHandler)
{
	var user = assert getUser(userId)
	user.removeConnection(connection)
	connectionSize--
	logDebug("Connection closed. Now: (" .. String.forInteger(connectionSize) .. "/" .. String.forInteger(getUserCount()) .. ") connected")
	if not user.isOnline() {
		logDebug("User: '" .. user.getUserId() .. "' is now offline with last active on: " .. String.forLongInteger(user.getLastActive()))
		onUserOffline(user)
	}
}

func onParseData(data as buffer, connection as ChatConnectionHandler) private
{
	assert connection
	assert data {
		logError("No data buffer received. Closing the connection instead.")
		connection.close()
	}
	var message = assert createMessage(data) {
		logError("No ChatMessage instance returned by createMessage() abstract method. Closing the connection instead.")
		connection.close()
	}
	switch message.getMessageType() {
		case ChatMessage.COMMAND_TYPE: {
			// We would want to have commands
			// like: SEEN, TYPING, ONLINE, OFFLINE,
			// UPLOADING_FILE, DONE_UPLOADING_FILE, etc.
			onNewCommandMessage(message, connection)
			break
		}
		case ChatMessage.DATA_TYPE: {
			onNewDataMessage(message, connection)
			break
		}
		case ChatMessage.UNKNOWN_TYPE: {
			;
		}
		default: {
			logError("ChatMessage message type is invalid. Closing the connection instead.")
			connection.close()
		}
	}
}

func onNewDataMessage(message as ChatMessage, connection as ChatConnectionHandler)
{
	var channelId = message.getChannelId()
	if String.isEmpty(channelId) {
		channelId = createChannelAndGetId(message)
		message.setChannelId(channelId)
	}
	var c = assert getChannel(channelId):
		connection.close()
	c.onNewDataMessage(message)
}

func createChannelAndGetId(message as ChatMessage) private as string
{
	assert message
	assert checkRecipients(message.getRecipients()):
		logError("No recipients or recipient count is less than two returned by checkRecipients() method.")
	var channel = assert createChannel(message):
		logError("No ChatChannel instance returned by createChannel() abstract method.")
	var channelId = channel.getChannelId()
	assert String.isNotEmpty(channelId):
		logError("Created ChatChannel instance returned by createChannel() abstract method doesn't have channelId.")
	logDebug("New channel '" .. channelId .. "' created")
	return channelId
}

func broadcastMessage(message as ChatMessage)
{
	assert message
	var recipients = message.getRecipients()
	assert checkRecipients(recipients):
		logError("No recipients or recipient count is less than two returned by checkRecipients() method.")
	foreach(userId as string in recipients.toVector()) {
		var user = assert getUser(userId):
			logError("Invalid recipient with userId: '" .. userId .. "'. Stopping broadcast message.")
		if not user.isOnline() {
			logDebug("User: '" .. user.getUserId() .. "' is offline with last active on: " .. String.forLongInteger(user.getLastActive()) .. ". Sending notification instead.")
			if message.getMessageType() == ChatMessage.DATA_TYPE:
				notifyUserForNewDataMessage(user, message)
			continue
		}
		var brokenConnections = new vector<string>
		foreach(connectionId as string in user.getConnectionIds()) {
			var connection = user.getConnection(connectionId)
			if connection == null{
				brokenConnections += connectionId
				continue
			}
			var r = connection.sendMessage(message)
			if r < 1 {
				brokenConnections += connectionId
			}
		}
		foreach(connectionId as string in brokenConnections):
			user.removeConnectionForId(connectionId)
		if not user.isOnline() {
			logDebug("User: '" .. user.getUserId() .. "' is offline with last active on: " .. String.forLongInteger(user.getLastActive()) .. ". Sending notification instead.")
			if message.getMessageType() == ChatMessage.DATA_TYPE:
				notifyUserForNewDataMessage(user, message)
			continue
		}
	}
}
